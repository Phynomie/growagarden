local library = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Phynomie/growagarden/main/Library"))()
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

-- Load Notification module
local Notification
local success, err = pcall(function()
    Notification = require(ReplicatedStorage.Modules.Notification)
end)
if not success then
    warn("Failed to load Notification module: "..tostring(err))
    -- Fallback to default notifications
    Notification = {
        CreateNotification = function(text)
            StarterGui:SetCore("SendNotification", {
                Title = "GAG Script",
                Text = text,
                Duration = 5
            })
        end
    }
end

-- Rarity color mapping
local RARITY_COLORS = {
    Common = "#FFFFFF",       -- White
    Uncommon = "#00FF00",     -- Light Green
    Rare = "#0000FF",         -- Blue
    Legendary = "#FFFF00",    -- Light Yellow
    Mythical = "#800080",     -- Light Purple
    Divine = "#FFA500",       -- Orange
    Prismatic = "#00FFFF",    -- Aqua
    Transcendent = "#000000"  -- Black
}

local function getRarityColor(rarityText)
    -- Extract the actual rarity name from the text (e.g., "Rarity: Common" -> "Common")
    local rarity = rarityText:gsub("Rarity: ", ""):gsub("%s+", "")
    return RARITY_COLORS[rarity] or RARITY_COLORS.Common
end

local function createColoredNotification(text, rarityText)
    local color = getRarityColor(rarityText)
    if color == RARITY_COLORS.Common then
        -- Default color (no HTML tags)
        Notification:CreateNotification(text)
    else
        Notification:CreateNotification(string.format('<font color="%s">%s</font>', color, text))
    end
end

local cleanupInstances = {
    countdownGui = nil,
    connections = {},
    loops = {}
}

local Main = library:CreateWindow("Grow a garden script (Creds to Phy)","Crimson")

local tab = Main:CreateTab("Exploits")
local tab2 = Main:CreateTab("Automation")
local tab3 = Main:CreateTab("Misc")

-- Farm protection system
local savedPrompts = {}
local playerFarm = nil
local enabled = nil

local function findPlayerFarm()
    local username = LocalPlayer.Name
    local farms = workspace:FindFirstChild("Farm")
    
    if not farms then
        warn("Farm system not found in workspace")
        return nil
    end

    for _, farmFolder in ipairs(farms:GetDescendants()) do
        if farmFolder.Name == "Owner" and farmFolder:IsA("StringValue") and farmFolder.Value == username then
            print("Found Your Farm! " .. username)
            return farmFolder.Parent.Parent.Parent
        end
    end
    
    warn("Could not find farm belonging to: " .. username)
    return nil
end

local function managePrompts(enable)
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return end
    end

    for _, prompt in ipairs(playerFarm:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") then
            local isEggORCratePrompt = false
            local current = prompt.Parent
            while current ~= nil and current ~= playerFarm do
                if current.Name == "PetEgg" or current.Name == "CosmeticCrate" then
                    isEggORCratePrompt = true
                    break
                end
                current = current.Parent
            end
            
            if not isEggORCratePrompt then
                if enable then
                    if not savedPrompts[prompt] then
                        savedPrompts[prompt] = {
                            Enabled = prompt.Enabled,
                            HoldDuration = prompt.HoldDuration,
                            ActionText = prompt.ActionText
                        }
                    end
                    prompt.Enabled = false
                    prompt.HoldDuration = math.huge
                    prompt.ActionText = "Disabled"
                else
                    if savedPrompts[prompt] then
                        prompt.Enabled = savedPrompts[prompt].Enabled
                        prompt.HoldDuration = savedPrompts[prompt].HoldDuration
                        prompt.ActionText = savedPrompts[prompt].ActionText
                    end
                end
            end
        end
    end
end

local function simulateClick(x, y)
    VirtualInputManager:SendMouseMoveEvent(x, y, game)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    task.wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function sendNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 5,
        Icon = "rbxassetid://6726579484"
    })
end

local function autoBuySeeds()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local seedShop = LocalPlayer.PlayerGui:FindFirstChild("Seed_Shop")
    if not seedShop then
        createColoredNotification("Seed shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = seedShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuySeedStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." seeds!", rarityText)
                end
            end
        end
    end
end

local function autoBuyGears()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local gearShop = LocalPlayer.PlayerGui:FindFirstChild("Gear_Shop")
    if not gearShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = gearShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyGearStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." gears!", rarityText)
                end
            end
        end
    end
end

local function autoBuyEggs()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local eggShop = LocalPlayer.PlayerGui:FindFirstChild("PetShop_UI")
    if not eggShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = eggShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyPetEgg"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                end
            end
        end
    end
end

local function autoBuyTM()
    -- First check if the shop is even open
    local TMShop = LocalPlayer.PlayerGui:FindFirstChild("TravelingMerchantShop_UI")
    if not TMShop then
        createColoredNotification("Traveling Merchant shop not open!", "Rarity: Common")
        return false
    end

    -- Check honey UI if it exists (for honey-based purchases)
    local honeyUI = LocalPlayer.PlayerGui:FindFirstChild("Honey_UI")
    local playerHoney = 0
    if honeyUI and honeyUI:FindFirstChild("Frame") and honeyUI.Frame:FindFirstChild("TextLabel1") then
        playerHoney = tonumber(honeyUI.Frame.TextLabel1.Text:match("%d+")) or 0
    end

    local scrollingFrame = TMShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return false end

    local madePurchase = false

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local priceText = mainFrame:FindFirstChild("Price_Text") -- Check for price text
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    -- Check if this is a honey purchase
                    local isHoneyPurchase = false
                    local price = 0
                    
                    if priceText then
                        local priceStr = priceText.Text:lower()
                        if priceStr:find("honey") then
                            isHoneyPurchase = true
                            price = tonumber(priceStr:match("%d+")) or 0
                        end
                    end

                    if isHoneyPurchase then
                        -- Honey-based item logic
                        if playerHoney >= price then
                            for i = 1, stockNum do
                                if playerHoney >= price then -- Check honey again in case it changed
                                    local args = {frame.Name}
                                    ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                    playerHoney = playerHoney - price
                                    task.wait(0.1)
                                    madePurchase = true
                                else
                                    createColoredNotification("Ran out of honey while purchasing "..frame.Name, "Rarity: Common")
                                    break
                                end
                            end
                            if madePurchase then
                                createColoredNotification("Bought "..stockNum.." "..frame.Name.." for honey!", rarityText)
                            end
                        else
                            createColoredNotification("You need "..price.." honey to buy "..frame.Name, "Rarity: Common")
                        end
                    else
                        -- Sheckles-based item logic
                        local sheckles = LocalPlayer.leaderstats.Sheckles.Value
                        if sheckles >= 10000000000 then -- 10B sheckles check
                            for i = 1, stockNum do
                                local args = {frame.Name}
                                ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                task.wait(0.1)
                                madePurchase = true
                            end
                            createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                        else
                            createColoredNotification("You need 10B sheckles to buy regular TM items", "Rarity: Common")
                            break
                        end
                    end
                end
            end
        end
    end

    return madePurchase
end

tab:CreateToggle("Anti Collect Fruits", function(a)
    if a then
        managePrompts(true)
    else
        managePrompts(false)
    end
end)

tab:CreateToggle("Weight Calculator", function(enabled)
    if enabled then
        print("[Weight Calculator] Enabling...")

        -- Create the tool
        local weightTool = Instance.new("Tool")
        weightTool.Name = "Weight Calculator"
        weightTool.RequiresHandle = false
        weightTool.CanBeDropped = false

        local toolTip = Instance.new("StringValue")
        toolTip.Name = "ToolTip"
        toolTip.Value = "Touch/Click fruits to check weight"
        toolTip.Parent = weightTool

        weightTool.Parent = LocalPlayer.Backpack
        print("[Weight Calculator] Tool created in backpack")

        -- Main function to check weight
        local function checkWeight(target)
            print("[Weight Calculator] Checking weight for:", target:GetFullName())

            local plant = target:FindFirstAncestorWhichIsA("Model")
            while plant do
                if plant:HasTag("Harvestable") then
                    break
                end
                plant = plant:FindFirstAncestorWhichIsA("Model")
            end

            if plant then
                print("[Weight Calculator] Found harvestable plant:", plant:GetFullName())

                local weight = plant:FindFirstChild("Weight") or
                               (plant:FindFirstChild("Fruits") and plant.Fruits:FindFirstChildWhichIsA("BasePart"):FindFirstChild("Weight"))

                if weight and weight:IsA("NumberValue") then
                    local weightKg = weight.Value
                    print("[Weight Calculator] Found weight:", weightKg)

                    -- Define base value per plant (this is the 'value' part of the formula)
                    -- These values are crucial to get the Trillion-level results you expect.
                    local baseValues = {
                        ["Bone Blossom"] = 22222, -- Confirmed for both 51.396kg and 51.397kg examples
                        ["Elephant Ears"] = 237.600000000049107,                  -- Derived from your 150kg -> 1.084T example
                        -- Add more plants here as needed with their corresponding base values
                        -- If a plant name isn't found here, it will default to '100000'
                    }

                    -- Define rarity multipliers. Gold is set to 20 as per your previous message.
                    -- We explicitly use the Rainbow multiplier for 'max mutation' value.
                    local rarityMultipliers = {
                        ["Gold"] = 20,   
                        ["Rainbow"] = 50, 
                        -- Add other rarities if needed for future flexibility, but not used for max mutation
                    }

                    local name = plant.Name
                    -- The actual rarity of the plant is not used for the calculation, but kept for display.
                    local actualRarity = plant:FindFirstChild("Rarity") and plant.Rarity.Value or "Common"

                    local base = baseValues[name] or 100000 -- fallback if not defined
                    
                    -- *** ALWAYS USE RAINBOW MULTIPLIER FOR MAX MUTATION VALUE ***
                    local rarityMultiplierForCalculation = rarityMultipliers["Rainbow"] 

                    print("name of da fruit:", name)
                    print("Actual Rarity of plant:", actualRarity) -- Show the plant's true rarity
                    print("Calculated Base from table:", base) 
                    print("Rarity Multiplier Used (forced to Rainbow):", rarityMultiplierForCalculation) 

                    -- These values (sumOfModifiers, numModifiers) are constant based on your input
                    local sumOfModifiers = 1566
                    local numModifiers = 32

                    local combinedModifierPart = rarityMultiplierForCalculation * (1 + sumOfModifiers - numModifiers)
                    print("Combined Modifier Part:", combinedModifierPart) 

                    -- Final calculation using the exact formula: value * weight^2 * ((rainbow/gold)*(1+sum-number))
                    local totalValue = base * (weightKg ^ 2) * combinedModifierPart
                    print("Total Calculated Value (raw):", totalValue) 


                    -- Format function
                    local function formatBillions(num)
                        if num >= 1e12 then
                            return string.format("$%.0f (%.3f Trillion)", num, num / 1e12)
                        elseif num >= 1e9 then
                            return string.format("$%.0f (%.3f Billion)", num, num / 1e9)
                        elseif num >= 1e6 then
                            return string.format("$%.0f (%.3f Million)", num, num / 1e6)
                        else
                            return string.format("$%.0f", num)
                        end
                    end

                    local formattedValue = formatBillions(totalValue)

                    -- The notification will now reflect the calculated value assuming Rainbow mutation
                    createColoredNotification(string.format("%s\nWeight: %.3f kg\nEstimated Value (Max Mutation): %s", name, weightKg, formattedValue), "Rarity: " .. actualRarity)

                    -- Highlight
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "WeightHighlight"
                    highlight.FillColor = Color3.new(1, 0.5, 0)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0
                    highlight.Adornee = plant
                    highlight.Parent = workspace

                    task.delay(2, function()
                        highlight:Destroy()
                    end)
                else
                    print("[Weight Calculator] No weight value found on plant")
                end
            else
                print("[Weight Calculator] No harvestable plant found in ancestry")
            end
        end
        -- Mobile touch detection
        if UserInputService.TouchEnabled then
            print("[Weight Calculator] Mobile device detected - setting up touch input")

            local touchConnection
            touchConnection = UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
                if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                    print("[Weight Calculator] Tool not equipped - ignoring touch")
                    return
                end

                print(string.format("[Weight Calculator] Touch detected at (%d, %d)", touch.Position.X, touch.Position.Y))

                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(touch.Position.X, touch.Position.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Touch hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Touch didn't hit anything")
                end
            end)
            cleanupInstances.connections["WeightTouch"] = touchConnection
        else
            print("[Weight Calculator] PC detected - setting up mouse input")
        end

        -- PC click detection
        local clickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                print("[Weight Calculator] Tool not equipped - ignoring click")
                return
            end

            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                print("[Weight Calculator] Mouse click detected")

                local mousePos = UserInputService:GetMouseLocation()
                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Click hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Click didn't hit anything")
                end
            end
        end)
        cleanupInstances.connections["WeightClick"] = clickConnection

        -- Tool equipped handling
        local function onEquipped()
            print("[Weight Calculator] Tool equipped")
            createColoredNotification("Weight Calculator ready\nTouch/Click fruits to check weight", "Rarity: Common")
        end

        weightTool.Equipped:Connect(onEquipped)
        weightTool.Unequipped:Connect(function()
            print("[Weight Calculator] Tool unequipped")
        end)

        createColoredNotification("Weight Calculator enabled\nEquip the tool from your backpack", "Rarity: Common")
    else
        print("[Weight Calculator] Disabling...")

        -- Cleanup connections
        for name, conn in pairs(cleanupInstances.connections) do
            if name:find("Weight") then
                conn:Disconnect()
                cleanupInstances.connections[name] = nil
                print("[Weight Calculator] Disconnected:", name)
            end
        end

        -- Remove tool
        if LocalPlayer.Backpack:FindFirstChild("Weight Calculator") then
            LocalPlayer.Backpack["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed tool from backpack")
        end

        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator") then
            LocalPlayer.Character["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed equipped tool")
        end

        createColoredNotification("Weight Calculator disabled", "Rarity: Common")
    end
end)

tab:CreateToggle("Anti-Kick", function(enabled)
    local namecallHook
    
    if enabled then
        -- Create the hook when toggle is enabled
        namecallHook = hookmetamethod(game.Players.LocalPlayer, "__namecall", function(...)
            local method = getnamecallmethod()
            if method == "Kick" then
                print("[Anti-Kick] Blocked kick attempt")
                return nil
            end
            return namecallHook(...)
        end)

        -- Verify the hook was successful
        if typeof(namecallHook) == "function" then
            print("[Anti-Kick] Protection enabled successfully")
        else
            warn("[Anti-Kick] Failed to create protection!")
            return
        end

        -- Store the hook in cleanup table
        cleanupInstances.connections["AntiKick"] = namecallHook
    else
        -- Disable the hook when toggle is turned off
        if cleanupInstances.connections["AntiKick"] then
            if unhookmetamethod then
                unhookmetamethod(game.Players.LocalPlayer, "__namecall", cleanupInstances.connections["AntiKick"])
            end
            cleanupInstances.connections["AntiKick"] = nil
            print("[Anti-Kick] Protection disabled")
        end
    end
end)

tab:CreateToggle("Anti-Afk", function(enabled)
    if enabled then
        sendNotification("✅ Anti-AFK", "Anti AFK has been enabled.", 5)
        
        -- Disable all existing Idled connections
        for _, connection in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
            connection:Disable()
            -- Store disabled connections for re-enabling later
            table.insert(cleanupInstances.connections, {
                connection = connection,
                enabled = connection.Enabled -- Store original state
            })
        end
        
        -- Create a new simulated activity loop
        local antiAfkLoop = game:GetService("RunService").Heartbeat:Connect(function()
            game:GetService("VirtualUser"):Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            game:GetService("VirtualUser"):Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        end)
        
        -- Store the loop in cleanup
        cleanupInstances.connections["AntiAfkLoop"] = antiAfkLoop
        
    else
        sendNotification("❌ Anti-AFK", "Anti AFK has been disabled.", 5)
        
        -- Re-enable original Idled connections
        for _, connectionData in pairs(cleanupInstances.connections) do
            if typeof(connectionData) == "table" and connectionData.connection then
                connectionData.connection.Enabled = connectionData.enabled
            end
        end
        
        -- Disconnect the activity loop
        if cleanupInstances.connections["AntiAfkLoop"] then
            cleanupInstances.connections["AntiAfkLoop"]:Disconnect()
            cleanupInstances.connections["AntiAfkLoop"] = nil
        end
    end
end)

tab:CreateButton("Sell Equipped Fruit", function()
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return
    end
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return
    end
    
    local originalCFrame = playerHRP.CFrame
    
    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    
    task.wait(0.2)
    
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Item"):FireServer()
    
    task.wait(0.2)
    
    playerHRP.CFrame = originalCFrame
end)

tab:CreateButton("Sell All Fruits", function()
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return
    end
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return
    end
    
    local originalCFrame = playerHRP.CFrame
    
    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    
    task.wait(0.2)
    
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Inventory"):FireServer()
    
    task.wait(0.2)
    
    playerHRP.CFrame = originalCFrame
end)

local autoBuyActive = false
cleanupInstances.loops.buyLoop = nil

local countdownGui = Instance.new("ScreenGui")
countdownGui.Name = "AutoBuyCountdown"
countdownGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 50)
frame.Position = UDim2.new(0.085, 0, 0.7, 0)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
frame.BackgroundTransparency = 0.5
frame.BorderSizePixel = 0
frame.Visible = false
frame.Parent = countdownGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0.4, 0)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Next Auto-Buy In:"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.Gotham
title.TextSize = 14
title.Parent = frame

local timerText = Instance.new("TextLabel")
timerText.Size = UDim2.new(1, 0, 0.6, 0)
timerText.Position = UDim2.new(0, 0, 0.4, 0)
timerText.BackgroundTransparency = 1
timerText.Text = "60s"
timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
timerText.Font = Enum.Font.GothamBold
timerText.TextSize = 18
timerText.Parent = frame

local progressBar = Instance.new("Frame")
progressBar.Size = UDim2.new(1, 0, 0, 3)
progressBar.Position = UDim2.new(0, 0, 1, -3)
progressBar.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
progressBar.BorderSizePixel = 0
progressBar.Parent = frame

local progressFill = Instance.new("Frame")
progressFill.Size = UDim2.new(1, 0, 1, 0)
progressFill.Position = UDim2.new(0, 0, 0, 0)
progressFill.BackgroundColor3 = Color3.fromRGB(220, 20, 60) -- Crimson
progressFill.BorderSizePixel = 0
progressFill.Parent = progressBar

local function stopBuyLoop()
    if cleanupInstances.loops.buyLoop then
        cleanupInstances.loops.buyLoop = nil
    end
    autoBuyActive = false
    frame.Visible = false
end

local function startBuyLoop()
    cleanupInstances.loops.buyLoop = coroutine.create(function()
        while autoBuyActive do
            frame.Visible = true
            
            autoBuySeeds()
            autoBuyGears()
            autoBuyEggs()
            autoBuyTM()
            
            for i = 60, 1, -1 do
                if not autoBuyActive then break end
                
                timerText.Text = i.."s"
                progressFill.Size = UDim2.new(i/60, 0, 1, 0)
                
                local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(progressFill, tweenInfo, {Size = UDim2.new((i-1)/60, 0, 1, 0)})
                tween:Play()
                
                task.wait(1)
            end
        end
        stopBuyLoop()
    end)
    coroutine.resume(cleanupInstances.loops.buyLoop)
end

tab2:CreateToggle("Auto Buy Seed/Gear/Egg/TM", function(a)
    autoBuyActive = a
    
    if a then
        if not cleanupInstances.loops.buyLoop then
            startBuyLoop()
        end
    else
        stopBuyLoop()
    end
end)

local selectedMutation = nil
local autoPickupActive = false

-- List of attributes to ignore in the dropdown
local IGNORED_ATTRIBUTES = {
    "DoneGrowTime",
    "GrowRateMulti",
    "MaxAge",
    "FruitSpawnIndex",
    "FruitVersion",
    "WeightMulti",
    "SetVariant",
    "IsOutlined",
    "Inspected",
    "SkipRotation"
}

-- Function to scan farm for all available mutations (excluding ignored ones)
local function scanForMutations()
    local mutationList = {}
    
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return mutationList end
    end

    local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
    if plantsPhysical then
        for _, plant in pairs(plantsPhysical:GetChildren()) do
            -- Check for Fruits folder
            local fruitsFolder = plant:FindFirstChild("Fruits")
            if fruitsFolder then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    -- Get all attributes (mutations)
                    for attrName, _ in pairs(fruit:GetAttributes()) do
                        -- Only add if not in ignored list
                        if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                            table.insert(mutationList, attrName)
                        end
                    end
                end
            else
                -- Check the plant itself if no Fruits folder
                for attrName, _ in pairs(plant:GetAttributes()) do
                    if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                        table.insert(mutationList, attrName)
                    end
                end
            end
        end
    end
    
    return mutationList
end

local trowelToggle = tab2:CreateToggle("Auto Trowel (Bone Blossom)", function(enabled)
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then 
        createColoredNotification("Backpack not found!", "Rarity: Common")
        return 
    end
    
    local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    
    if enabled then
        -- Search for any tool containing "Trowel" in backpack
        local trowelTool
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and string.find(string.lower(item.Name), "trowel") then
                trowelTool = item
                break
            end
        end
        
        if not trowelTool then
            createColoredNotification("No trowel found in backpack!", "Rarity: Common")
            return
        end
        
        -- If holding a tool, put it in backpack
        if currentTool then
            currentTool.Parent = backpack
        end
        
        -- Equip the trowel
        trowelTool.Parent = LocalPlayer.Character
        createColoredNotification(trowelTool.Name.." equipped", "Rarity: Common")
        
        -- Function to simulate mouse click on Bone Blossom plants
        local function useTrowelOnBoneBlossom()
            if not enabled then return end
            
            -- Find player's farm
            local farm = findPlayerFarm()
            if not farm then
                createColoredNotification("Couldn't find your farm!", "Rarity: Common")
                return
            end
            
            -- Look for Bone Blossom plants in Plants_Physical
            local plantsPhysical = farm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
            if not plantsPhysical then return end
            
            for _, plant in ipairs(plantsPhysical:GetChildren()) do
                if plant.Name == "Bone Blossom" then
                    -- Get the plant's position on screen
                    local camera = workspace.CurrentCamera
                    local plantPart = plant:FindFirstChild("Stem") or plant:FindFirstChildWhichIsA("BasePart")
                    if not plantPart then continue end
                    
                    local screenPos, onScreen = camera:WorldToViewportPoint(plantPart.Position)
                    if not onScreen then continue end
                    
                    -- Simulate mouse click at plant's position
                    local mousePos = Vector2.new(screenPos.X, screenPos.Y)
                    
                    -- Call the original ProcessInput function with mouse position
                    ProcessInput_upvr(mousePos)
                    
                    createColoredNotification("Used trowel on Bone Blossom", "Rarity: Common")
                    return true
                end
            end
            
            createColoredNotification("No Bone Blossom plants found!", "Rarity: Common")
            return false
        end
        
        -- Try to use trowel immediately
        local success = useTrowelOnBoneBlossom()
        
        -- Set up periodic checking if not successful
        if not success then
            cleanupInstances.loops["AutoTrowelLoop"] = game:GetService("RunService").Heartbeat:Connect(function()
                if not enabled then
                    cleanupInstances.loops["AutoTrowelLoop"]:Disconnect()
                    return
                end
                
                -- Check every 5 seconds
                if os.time() % 5 == 0 then
                    useTrowelOnBoneBlossom()
                end
            end)
        end
    else
        -- If holding a tool that contains "Trowel", put it back
        if currentTool and string.find(string.lower(currentTool.Name), "trowel") then
            currentTool.Parent = backpack
            createColoredNotification(currentTool.Name.." unequipped", "Rarity: Common")
        end
        
        -- Clean up any running loops
        if cleanupInstances.loops["AutoTrowelLoop"] then
            cleanupInstances.loops["AutoTrowelLoop"]:Disconnect()
            cleanupInstances.loops["AutoTrowelLoop"] = nil
        end
        
        -- Cancel any active trowel operation
        Cancel_upvr()
    end
end)

-- Create the mutation dropdown with filtered mutations
local mutationDropdown = tab2:CreateDDO("Select Mutation", {}, function(selected)
    selectedMutation = selected
end)

-- Update mutation list initially and when farm changes (with ignored attributes filtered out)
task.spawn(function()
    while true do
        local mutations = scanForMutations() -- This now returns only non-ignored attributes
        mutationDropdown:SetOptions(mutations)
        wait(30) -- Rescan every 30 seconds
    end
end)

-- Auto pickup function (unchanged)
local function collectFruitsWithMutation()
    while autoPickupActive and selectedMutation do
        if not playerFarm then
            playerFarm = findPlayerFarm()
            if not playerFarm then break end
        end

        local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
        if plantsPhysical then
            for _, plant in pairs(plantsPhysical:GetChildren()) do
                -- Recursive function to scan all fruit parts
                local function scanFruitModel(model)
                    if model:GetAttribute(selectedMutation) then
                        -- Find the proximity prompt at any level
                        local prompt = model:FindFirstChildWhichIsA("ProximityPrompt")
                        if not prompt then
                            -- Deep search for prompts in all descendants
                            for _, descendant in pairs(model:GetDescendants()) do
                                if descendant:IsA("ProximityPrompt") then
                                    prompt = descendant
                                    break
                                end
                            end
                        end
                        
                        -- If prompt found, collect the fruit
                        if prompt then
                            -- Teleport to fruit
                            local char = LocalPlayer.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                local hrp = char.HumanoidRootPart
                                local originalPos = hrp.CFrame
                                
                                -- Teleport close to fruit
                                hrp.CFrame = model:GetPivot() * CFrame.new(0, 0, -2)
                                
                                -- Fire prompt
                                task.wait(0.2)
                                fireproximityprompt(prompt)
                                
                                -- Return to original position
                                task.wait(0.1)
                                hrp.CFrame = originalPos
                            end
                        end
                    end
                end

                -- Check both Fruits folder and direct children
                local fruitsFolder = plant:FindFirstChild("Fruits")
                if fruitsFolder then
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        -- Scan the fruit and all its nested children
                        scanFruitModel(fruit)
                        for _, subPart in pairs(fruit:GetDescendants()) do
                            if subPart:IsA("Model") or subPart:IsA("BasePart") then
                                scanFruitModel(subPart)
                            end
                        end
                    end
                else
                    -- Check the plant itself if no Fruits folder
                    scanFruitModel(plant)
                end
            end
        end
        
        task.wait(0.5) -- Delay between scans
    end
end

-- Create the toggle (unchanged)
tab2:CreateToggle("Auto Pickup Fruits with mutation", function(state)
    autoPickupActive = state
    if state then
        if not selectedMutation then
            sendNotification("Pickup Error", "Select a mutation first!", 5)
            return
        end
        task.spawn(collectFruitsWithMutation)
        sendNotification("Auto Pickup", "Started collecting "..selectedMutation, 5)
    else
        sendNotification("Auto Pickup", "Stopped collecting", 3)
    end
end)

tab3:CreateButton("Sprinkler Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Phynomie/tg/refs/heads/main/script.lua"))()
end)

tab:Show()

library.OnDestroy = function()
    print("Destroying all created instances...")
    
    -- Stop all loops
    for _, loop in pairs(cleanupInstances.loops) do
        if type(loop) == "thread" then
            coroutine.close(loop)
        end
    end
    
    -- Disconnect all connections
    for _, connection in ipairs(cleanupInstances.connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    
    -- Reset prompts
    managePrompts(false)
    
    -- Destroy GUI instances
    if cleanupInstances.countdownGui then
        cleanupInstances.countdownGui:Destroy()
    end
    
    -- Reset variables
    enabled = nil
    autoBuyActive = false
    savedPrompts = {}
    playerFarm = nil
    
    -- Clear tables
    cleanupInstances.connections = {}
    cleanupInstances.loops = {}
    
    print("Cleanup complete!")
end
