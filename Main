if getgenv().script_loaded then return end
getgenv().script_loaded = true

local library = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Phynomie/growagarden/main/Library"))()
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local Notification
local success, err = pcall(function()
    Notification = require(ReplicatedStorage.Modules.Notification)
end)
if not success then
    warn("Failed to load Notification module: "..tostring(err))
    Notification = {
        CreateNotification = function(text)
            StarterGui:SetCore("SendNotification", {
                Title = "GAG Script",
                Text = text,
                Duration = 5
            })
        end
    }
end

local RARITY_COLORS = {
    Common = "#FFFFFF",      
    Uncommon = "#00FF00",     
    Rare = "#0000FF",        
    Legendary = "#FFFF00", 
    Mythical = "#800080",    
    Divine = "#FFA500",       
    Prismatic = "#00FFFF",   
    Transcendent = "#000000"  
}

local automationToggles = {
    kitsune = nil,
    tranquil = nil
}

local function getRarityColor(rarityText)
    local rarity = rarityText:gsub("Rarity: ", ""):gsub("%s+", "")
    return RARITY_COLORS[rarity] or RARITY_COLORS.Common
end

local function createColoredNotification(text, rarityText)
    local color = getRarityColor(rarityText)
    if color == RARITY_COLORS.Common then
        Notification:CreateNotification(text)
    else
        Notification:CreateNotification(string.format('<font color="%s">%s</font>', color, text))
    end
end

local cleanup = {
    connections = {},
    instances = {},
    loops = {},
    hooks = {}
}

local Main = library:CreateWindow("Grow a garden script (Creds to Phy)","Crimson")

local tab = Main:CreateTab("Exploits")
local tab2 = Main:CreateTab("Automation")
local tab3 = Main:CreateTab("Misc")

local savedPrompts = {}
local playerFarm = nil
local enabled = nil

local function findPlayerFarm()
    local username = LocalPlayer.Name
    local farms = workspace:FindFirstChild("Farm")
    
    if not farms then
        warn("Farm system not found in workspace")
        return nil
    end

    for _, farmFolder in ipairs(farms:GetDescendants()) do
        if farmFolder.Name == "Owner" and farmFolder:IsA("StringValue") and farmFolder.Value == username then
            print("Found Your Farm! " .. username)
            return farmFolder.Parent.Parent.Parent
        end
    end
    
    warn("Could not find farm belonging to: " .. username)
    return nil
end

local function managePrompts(enable)
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return end
    end

    for _, prompt in ipairs(playerFarm:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") then
            local isEggORCratePrompt = false
            local current = prompt.Parent
            while current ~= nil and current ~= playerFarm do
                if current.Name == "PetEgg" or current.Name == "CosmeticCrate" then
                    isEggORCratePrompt = true
                    break
                end
                current = current.Parent
            end
            
            if not isEggORCratePrompt then
                if enable then
                    if not savedPrompts[prompt] then
                        savedPrompts[prompt] = {
                            Enabled = prompt.Enabled,
                            HoldDuration = prompt.HoldDuration,
                            ActionText = prompt.ActionText
                        }
                    end
                    prompt.Enabled = false
                    prompt.HoldDuration = math.huge
                    prompt.ActionText = "Disabled"
                else
                    if savedPrompts[prompt] then
                        prompt.Enabled = savedPrompts[prompt].Enabled
                        prompt.HoldDuration = savedPrompts[prompt].HoldDuration
                        prompt.ActionText = savedPrompts[prompt].ActionText
                    end
                end
            end
        end
    end
end

local function simulateClick(x, y)
    VirtualInputManager:SendMouseMoveEvent(x, y, game)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    task.wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function sendNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 5,
        Icon = "rbxassetid://6726579484"
    })
end

local function autoBuySeeds()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local seedShop = LocalPlayer.PlayerGui:FindFirstChild("Seed_Shop")
    if not seedShop then
        createColoredNotification("Seed shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = seedShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuySeedStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." seeds!", rarityText)
                end
            end
        end
    end
end

local function autoBuyGears()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local gearShop = LocalPlayer.PlayerGui:FindFirstChild("Gear_Shop")
    if not gearShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = gearShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyGearStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." gears!", rarityText)
                end
            end
        end
    end
end

local function autoBuyEggs()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then 
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local eggShop = LocalPlayer.PlayerGui:FindFirstChild("PetShop_UI")
    if not eggShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = eggShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyPetEgg"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                end
            end
        end
    end
end

local function autoBuyTM()
    local TMShop = LocalPlayer.PlayerGui:FindFirstChild("TravelingMerchantShop_UI")
    if not TMShop then
        createColoredNotification("Traveling Merchant shop not open!", "Rarity: Common")
        return false
    end

    local honeyUI = LocalPlayer.PlayerGui:FindFirstChild("Honey_UI")
    local playerHoney = 0
    if honeyUI and honeyUI:FindFirstChild("Frame") and honeyUI.Frame:FindFirstChild("TextLabel1") then
        playerHoney = tonumber(honeyUI.Frame.TextLabel1.Text:match("%d+")) or 0
    end

    local scrollingFrame = TMShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return false end

    local madePurchase = false

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local priceText = mainFrame:FindFirstChild("Price_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    local isHoneyPurchase = false
                    local price = 0
                    
                    if priceText then
                        local priceStr = priceText.Text:lower()
                        if priceStr:find("honey") then
                            isHoneyPurchase = true
                            price = tonumber(priceStr:match("%d+")) or 0
                        end
                    end

                    if isHoneyPurchase then
                        if playerHoney >= price then
                            for i = 1, stockNum do
                                if playerHoney >= price then
                                    local args = {frame.Name}
                                    ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                    playerHoney = playerHoney - price
                                    task.wait(0.1)
                                    madePurchase = true
                                else
                                    createColoredNotification("Ran out of honey while purchasing "..frame.Name, "Rarity: Common")
                                    break
                                end
                            end
                            if madePurchase then
                                createColoredNotification("Bought "..stockNum.." "..frame.Name.." for honey!", rarityText)
                            end
                        else
                            createColoredNotification("You need "..price.." honey to buy "..frame.Name, "Rarity: Common")
                        end
                    else
                        local sheckles = LocalPlayer.leaderstats.Sheckles.Value
                        if sheckles >= 10000000000 then 
                            for i = 1, stockNum do
                                local args = {frame.Name}
                                ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                task.wait(0.1)
                                madePurchase = true
                            end
                            createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                        else
                            createColoredNotification("You need 10B sheckles to buy regular TM items", "Rarity: Common")
                            break
                        end
                    end
                end
            end
        end
    end

    return madePurchase
end

tab:CreateToggle("Anti Collect Fruits", function(a)
    if a then
        managePrompts(true)
    else
        managePrompts(false)
    end
end)

local rarityMultipliers = {
    ["Gold"] = 20,   
    ["Rainbow"] = 50
}

local fruitInfoEnabled = false
local fruitInfoFrame = nil

local function createFruitInfoUI()
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    if fruitInfoFrame then 
        fruitInfoFrame:Destroy()
        fruitInfoFrame = nil
        task.wait(0.1) 
    end
    
    fruitInfoFrame = Instance.new("ScreenGui")
    fruitInfoFrame.Name = "FruitInfoGUI"
    fruitInfoFrame.ResetOnSpawn = false
    fruitInfoFrame.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    fruitInfoFrame.DisplayOrder = 10 
    fruitInfoFrame.Parent = playerGui
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 300, 0, 200) 
    mainFrame.Position = UDim2.new(0.006, 0, 0.57, 0) 
    mainFrame.AnchorPoint = Vector2.new(0, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    mainFrame.BackgroundTransparency = 0.15
    mainFrame.BorderSizePixel = 0
    mainFrame.Visible = fruitInfoEnabled 
    mainFrame.Parent = fruitInfoFrame
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainFrame
    
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = Color3.fromRGB(100, 100, 255)
    uiStroke.Thickness = 2
    uiStroke.Parent = mainFrame
    
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BackgroundTransparency = 0.3
    titleBar.Parent = mainFrame
    
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -10, 1, 0)
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "FRUIT INFORMATION"
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 16
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar
    
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Size = UDim2.new(1, -10, 1, -40)
    contentFrame.Position = UDim2.new(0, 5, 0, 35)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame
    
    local nameFrame = Instance.new("Frame")
    nameFrame.Name = "NameFrame"
    nameFrame.Size = UDim2.new(1, 0, 0, 30)
    nameFrame.Position = UDim2.new(0, 0, 0, 0)
    nameFrame.BackgroundTransparency = 1
    nameFrame.Parent = contentFrame
    
    local nameScrollingFrame = Instance.new("ScrollingFrame")
    nameScrollingFrame.Name = "NameScroller"
    nameScrollingFrame.Size = UDim2.new(1, 0, 1, 0)
    nameScrollingFrame.Position = UDim2.new(0, 0, 0, 0)
    nameScrollingFrame.BackgroundTransparency = 1
    nameScrollingFrame.ScrollBarThickness = 4
    nameScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 255)
    nameScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.X
    nameScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    nameScrollingFrame.Parent = nameFrame
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(0, 0, 1, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = "No fruit equipped"
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.Font = Enum.Font.GothamSemibold
    nameLabel.TextSize = 18
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.TextWrapped = false 
    nameLabel.AutomaticSize = Enum.AutomaticSize.X 
    nameLabel.Parent = nameScrollingFrame
    
    local mutationsFrame = Instance.new("ScrollingFrame")
    mutationsFrame.Name = "MutationsFrame"
    mutationsFrame.Size = UDim2.new(1, 0, 0, 100)
    mutationsFrame.Position = UDim2.new(0, 0, 0, 35)
    mutationsFrame.BackgroundTransparency = 1
    mutationsFrame.ScrollBarThickness = 4
    mutationsFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 255)
    mutationsFrame.Parent = contentFrame
    
    local mutationsLayout = Instance.new("UIListLayout")
    mutationsLayout.Padding = UDim.new(0, 5)
    mutationsLayout.Parent = mutationsFrame
    
    local priceFrame = Instance.new("Frame")
    priceFrame.Name = "PriceFrame"
    priceFrame.Size = UDim2.new(1, 0, 0, 30)
    priceFrame.Position = UDim2.new(0, 0, -0.01, 135)
    priceFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 40)
    priceFrame.BackgroundTransparency = 0.5
    priceFrame.Parent = contentFrame
    
    local priceLabel = Instance.new("TextLabel")
    priceLabel.Name = "PriceLabel"
    priceLabel.Size = UDim2.new(1, -10, 1, 0)
    priceLabel.Position = UDim2.new(0, 10, 0, 0)
    priceLabel.BackgroundTransparency = 1
    priceLabel.Text = "Value: $0"
    priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    priceLabel.Font = Enum.Font.GothamBold
    priceLabel.TextSize = 16
    priceLabel.TextXAlignment = Enum.TextXAlignment.Left
    priceLabel.Parent = priceFrame

    local cornerUI = Instance.new("UICorner")
    cornerUI.CornerRadius = UDim.new(0.5, 8)
    cornerUI.Parent = priceFrame
    
    mainFrame.ZIndex = 10
    titleBar.ZIndex = 11
    titleText.ZIndex = 12
    contentFrame.ZIndex = 11
    nameFrame.ZIndex = 12
    nameScrollingFrame.ZIndex = 13
    nameLabel.ZIndex = 14
    mutationsFrame.ZIndex = 12
    priceFrame.ZIndex = 12
    priceLabel.ZIndex = 13
    
    return fruitInfoFrame
end

local Item_Module = require(ReplicatedStorage.Item_Module)
local MutationHandler = require(ReplicatedStorage.Modules.MutationHandler)
local InventoryServiceEnums = require(ReplicatedStorage.Data.EnumRegistry.InventoryServiceEnums)

local function CalculatePlantValue(plant)
    local Item_String = plant:FindFirstChild("Item_String")
    local itemName
    if Item_String and Item_String.Value ~= "" then
        itemName = Item_String.Value
    else
        itemName = plant.Name
    end

    local Variant = plant:FindFirstChild("Variant")
    if not Variant then
        return 0
    end

    local Weight = plant:FindFirstChild("Weight")
    if not Weight then
        return 0
    end

    local itemData = Item_Module.Return_Data(itemName)
    if not itemData or #itemData < 3 then
        warn("CalculatePlantValue | ItemData is invalid")
        return 0
    end

    local clamped = math.clamp(Weight.Value / itemData[2], 0.95, 100000000)
    local value = (itemData[3] * MutationHandler:CalcValueMulti(plant) * Item_Module.Return_Multiplier(Variant.Value)) * (clamped * clamped)
    
    if 1 <= (plant:GetAttribute(InventoryServiceEnums.FruitVersion) or 0) then
        value = math.min(value, 1000000000000)
    end
    
    return math.round(value)
end

local lastEquippedFruit = nil
local lastUpdateTime = 0
local UPDATE_COOLDOWN = 0.5
local lastKnownAttributes = nil
local lastKnownWeight = nil

local function updateFruitInfo()
    if not fruitInfoEnabled or not fruitInfoFrame then return end
    
    local currentTime = os.clock()
    if currentTime - lastUpdateTime < UPDATE_COOLDOWN then return end
    lastUpdateTime = currentTime

    local mainFrame = fruitInfoFrame:FindFirstChild("MainFrame")
    if not mainFrame then return end

    local character = game.Players.LocalPlayer.Character
    if not character then
        return
    end

    local equippedFruit = nil
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") then
            equippedFruit = item
            break
        end
    end

    if equippedFruit and lastEquippedFruit and equippedFruit == lastEquippedFruit then
        local attributesChanged = false
        local currentAttributes = {}
        
        for attrName, attrValue in pairs(equippedFruit:GetAttributes()) do
            if attrName ~= "d" and attrValue == true and attrName ~= "Weight" then
                table.insert(currentAttributes, attrName)
            end
        end
        
        if #currentAttributes ~= #lastKnownAttributes then
            attributesChanged = true
        else
            for _, attr in ipairs(currentAttributes) do
                if not table.find(lastKnownAttributes, attr) then
                    attributesChanged = true
                    break
                end
            end
        end

        if equippedFruit:FindFirstChild("Weight") then
            if not lastKnownWeight or equippedFruit.Weight.Value ~= lastKnownWeight then
                attributesChanged = true
            end
        end
        
        if not attributesChanged then
            return 
        end
    end

    if not equippedFruit then
        local nameLabel = mainFrame.ContentFrame.NameFrame.NameScroller.NameLabel
        nameLabel.Text = "No fruit equipped"

        local mutationsFrame = mainFrame.ContentFrame.MutationsFrame
        mutationsFrame:ClearAllChildren()
        local noMutations = Instance.new("TextLabel")
        noMutations.Size = UDim2.new(1, 0, 0, 20)
        noMutations.BackgroundTransparency = 1
        noMutations.Text = "No mutations"
        noMutations.TextColor3 = Color3.fromRGB(150, 150, 150)
        noMutations.Font = Enum.Font.Gotham
        noMutations.TextSize = 14
        noMutations.TextXAlignment = Enum.TextXAlignment.Left
        noMutations.ZIndex = 13
        noMutations.Parent = mutationsFrame
        mutationsFrame.CanvasSize = UDim2.new(0, 0, 0, noMutations.AbsoluteSize.Y)

        local priceLabel = mainFrame.ContentFrame.PriceFrame.PriceLabel
        priceLabel.Text = "Value: $0 , Weight: N/A"
        priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        
        lastEquippedFruit = nil
        lastKnownAttributes = nil
        lastKnownWeight = nil
        return
    end

    lastEquippedFruit = equippedFruit
    lastKnownAttributes = {}
    for attrName, attrValue in pairs(equippedFruit:GetAttributes()) do
        if attrName ~= "d" and attrValue == true and attrName ~= "Weight" then
            table.insert(lastKnownAttributes, attrName)
        end
    end
    
    if equippedFruit:FindFirstChild("Weight") then
        lastKnownWeight = equippedFruit.Weight.Value
    else
        lastKnownWeight = nil
    end

    local nameLabel = mainFrame.ContentFrame.NameFrame.NameScroller.NameLabel
    nameLabel.Text = equippedFruit.Name

    local mutationsFrame = mainFrame.ContentFrame.MutationsFrame
    mutationsFrame:ClearAllChildren()

    local mutationsLayout = Instance.new("UIListLayout")
    mutationsLayout.Padding = UDim.new(0, 5)
    mutationsLayout.Parent = mutationsFrame

    if #lastKnownAttributes > 0 then
        for _, mutation in ipairs(lastKnownAttributes) do
            local mutationLabel = Instance.new("TextLabel")
            mutationLabel.Size = UDim2.new(1, 0, 0, 20)
            mutationLabel.BackgroundTransparency = 1
            mutationLabel.Text = "• "..mutation:gsub("^%l", string.upper)
            mutationLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
            mutationLabel.Font = Enum.Font.Gotham
            mutationLabel.TextSize = 14
            mutationLabel.TextXAlignment = Enum.TextXAlignment.Left
            mutationLabel.ZIndex = 13
            mutationLabel.Parent = mutationsFrame
        end
    else
        local noMutations = Instance.new("TextLabel")
        noMutations.Size = UDim2.new(1, 0, 0, 20)
        noMutations.BackgroundTransparency = 1
        noMutations.Text = "No mutations"
        noMutations.TextColor3 = Color3.fromRGB(150, 150, 150)
        noMutations.Font = Enum.Font.Gotham
        noMutations.TextSize = 14
        noMutations.TextXAlignment = Enum.TextXAlignment.Left
        noMutations.ZIndex = 13
        noMutations.Parent = mutationsFrame
    end

    mutationsFrame.CanvasSize = UDim2.new(0, 0, 0, mutationsFrame.UIListLayout.AbsoluteContentSize.Y)

    local price = CalculatePlantValue(equippedFruit)
    local weight = lastKnownWeight or "???"
    local priceLabel = mainFrame.ContentFrame.PriceFrame.PriceLabel

    local priceString
    if price >= 1e12 then
        priceString = string.format("Value: $%.2fT", price/1e12)
        priceLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
    elseif price >= 1e9 then
        priceString = string.format("Value: $%.2fB", price/1e9)
        priceLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
    elseif price >= 1e6 then
        priceString = string.format("Value: $%.2fM", price/1e6)
        priceLabel.TextColor3 = Color3.fromRGB(144, 238, 144)
    else
        priceString = string.format("Value: $%.0f", price)
        priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    end

    priceLabel.Text = priceString .. string.format(" , Weight: %s", tostring(weight))
end

cleanup.connections["characterAdded"] = game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if fruitInfoEnabled then
        if fruitInfoFrame then
            fruitInfoFrame:Destroy()
            fruitInfoFrame = nil
        end
        fruitInfoFrame = createFruitInfoUI()
        updateFruitInfo()
    end
    cleanup.connections["childAdded"] = character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and fruitInfoEnabled then
            lastEquippedFruit = nil
            updateFruitInfo()
        end
    end)
end)

tab:CreateToggle("Show Fruit Info", function(state)
    fruitInfoEnabled = state
    
    if state then
        if not fruitInfoFrame or not fruitInfoFrame.Parent then
            fruitInfoFrame = createFruitInfoUI()
        end
        
        if fruitInfoFrame and fruitInfoFrame:FindFirstChild("MainFrame") then
            fruitInfoFrame.MainFrame.Visible = true
        end
        
        task.spawn(function()
            while fruitInfoEnabled do
                updateFruitInfo()
                task.wait(0.5)
            end
        end)
    elseif fruitInfoFrame and fruitInfoFrame:FindFirstChild("MainFrame") then
        fruitInfoFrame.MainFrame.Visible = false
    end
end)

local function CalculateMaxMutationValue(plantName, currentWeightValue)
    local itemData = Item_Module.Return_Data(plantName)
    if not itemData or #itemData < 3 then
        warn("CalculateMaxMutationValue | ItemData is invalid for " .. plantName)
        return 0
    end

    local baseValue = itemData[3]
    local baseWeightCap = itemData[2]


    local sumOfAllIndividualMutationMultipliers = 1939
    local numberOfIndividualMutations = 39
    local rainbowRarityMultiplier = 50

    local combinedMutationFactor = rainbowRarityMultiplier * (1 + sumOfAllIndividualMutationMultipliers - numberOfIndividualMutations)

    local clampedWeight = math.clamp(currentWeightValue / baseWeightCap, 0.95, 100000000)
    local weightSquaredFactor = clampedWeight * clampedWeight

    local finalMaxCalculatedValue = baseValue * weightSquaredFactor * combinedMutationFactor

    return math.round(finalMaxCalculatedValue)
end

tab:CreateToggle("Weight Calculator", function(enabled)
    if enabled then
        print("[Weight Calculator] Enabling...")

        local weightTool = Instance.new("Tool")
        weightTool.Name = "Weight Calculator"
        weightTool.RequiresHandle = false
        weightTool.CanBeDropped = false

        local toolTip = Instance.new("StringValue")
        toolTip.Name = "ToolTip"
        toolTip.Value = "Touch/Click fruits to check weight"
        toolTip.Parent = weightTool

        weightTool.Parent = LocalPlayer.Backpack
        print("[Weight Calculator] Tool created in backpack")

        local function checkWeight(target)
            print("[Weight Calculator] Checking weight for:", target:GetFullName())

            local plant = target:FindFirstAncestorWhichIsA("Model")
            while plant do
                if plant:HasTag("Harvestable") then
                    break
                end
                plant = plant:FindFirstAncestorWhichIsA("Model")
            end

            if plant then
                print("[Weight Calculator] Found harvestable plant:", plant:GetFullName())

                local weight = plant:FindFirstChild("Weight") or
                               (plant:FindFirstChild("Fruits") and plant.Fruits:FindFirstChildWhichIsA("BasePart"):FindFirstChild("Weight"))

                if weight and weight:IsA("NumberValue") then
                    local weightKg = weight.Value
                    print("[Weight Calculator] Found weight:", weightKg)

                    local name = plant.Name 
                    local actualRarity = plant:FindFirstChild("Rarity") and plant.Rarity.Value or "Common"

                    print("name of da fruit:", name)
                    print("Actual Rarity of plant:", actualRarity) 

                    local totalValueMaxMutation = CalculateMaxMutationValue(name, weightKg)
                    print("Estimated Value (Max Mutation, raw):", totalValueMaxMutation)

                    local function formatBillions(num)
                        if num >= 1e12 then
                            return string.format("$%.0f (%.3f Trillion)", num, num / 1e12)
                        elseif num >= 1e9 then
                            return string.format("$%.0f (%.3f Billion)", num, num / 1e9)
                        elseif num >= 1e6 then
                            return string.format("$%.0f (%.3f Million)", num, num / 1e6)
                        else
                            return string.format("$%.0f", num)
                        end
                    end

                    local formattedValue = formatBillions(totalValueMaxMutation)

                    createColoredNotification(string.format("%s\nWeight: %.3f kg\nEstimated Value (Max Mutation): %s", name, weightKg, formattedValue), "Rarity: " .. actualRarity)

                    local highlight = Instance.new("Highlight")
                    highlight.Name = "WeightHighlight"
                    highlight.FillColor = Color3.new(1, 0.5, 0)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0
                    highlight.Adornee = plant
                    highlight.Parent = workspace

                    task.delay(2, function()
                        highlight:Destroy()
                    end)
                else
                    print("[Weight Calculator] No weight value found on plant")
                end
            else
                print("[Weight Calculator] No harvestable plant found in ancestry")
            end
        end
        if UserInputService.TouchEnabled then
            print("[Weight Calculator] Mobile device detected - setting up touch input")

            local touchConnection
            touchConnection = UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
                if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                    print("[Weight Calculator] Tool not equipped - ignoring touch")
                    return
                end

                print(string.format("[Weight Calculator] Touch detected at (%d, %d)", touch.Position.X, touch.Position.Y))

                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(touch.Position.X, touch.Position.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Touch hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Touch didn't hit anything")
                end
            end)
            cleanup.connections["WeightTouch"] = touchConnection
        else
            print("[Weight Calculator] PC detected - setting up mouse input")
        end
        local clickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                print("[Weight Calculator] Tool not equipped - ignoring click")
                return
            end

            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                print("[Weight Calculator] Mouse click detected")

                local mousePos = UserInputService:GetMouseLocation()
                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Click hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Click didn't hit anything")
                end
            end
        end)
        cleanup.connections["WeightClick"] = clickConnection

        local function onEquipped()
            print("[Weight Calculator] Tool equipped")
            createColoredNotification("Weight Calculator ready\nTouch/Click fruits to check weight", "Rarity: Common")
        end

        cleanup.connections["weightToolEquipped"] = weightTool.Equipped:Connect(onEquipped)
        cleanup.connections["weightToolUnequipped"] = weightTool.Unequipped:Connect(function()
            print("[Weight Calculator] Tool unequipped")
        end)

        createColoredNotification("Weight Calculator enabled\nEquip the tool from your backpack", "Rarity: Common")
    else
        print("[Weight Calculator] Disabling...")

        for name, conn in pairs(cleanup.connections) do
            if name:find("Weight") then
                conn:Disconnect()
                cleanup.connections[name] = nil
                print("[Weight Calculator] Disconnected:", name)
            end
        end

        if LocalPlayer.Backpack:FindFirstChild("Weight Calculator") then
            LocalPlayer.Backpack["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed tool from backpack")
        end

        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator") then
            LocalPlayer.Character["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed equipped tool")
        end

        createColoredNotification("Weight Calculator disabled", "Rarity: Common")
    end
end)

local petCooldownEnabled = false
local petCooldownDisplays = {}
local petCooldownConnection = nil
local lastUpdateTime = 0
local UPDATE_INTERVAL = 2

local function createPetDisplay(pet)
    local head = pet:FindFirstChild("Head") or pet:FindFirstChildWhichIsA("BasePart")
    if not head then return nil end

    if head:FindFirstChild("PetCooldownDisplay") then
        head.PetCooldownDisplay:Destroy()
    end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PetCooldownDisplay"
    billboard.Size = UDim2.new(10, 0, 4, 0)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = head
    billboard.LightInfluence = 0
    billboard.MaxDistance = 150 
    billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    billboard.Parent = head

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = billboard

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "Loading..."
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 16
    textLabel.TextStrokeTransparency = 0.3
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.TextWrapped = true
    textLabel.Parent = frame

    if UserInputService.TouchEnabled then
        billboard.Size = UDim2.new(15, 0, 6, 0)
        billboard.StudsOffset = Vector3.new(0, 2.5, 0)
        textLabel.TextSize = 20
    end

    return textLabel
end

local function updatePetDisplay(petName, display)
    local success, cooldownData = pcall(function()
        return game:GetService("ReplicatedStorage").GameEvents.GetPetCooldown:InvokeServer(petName)
    end)

    if success and type(cooldownData) == "table" then
        local activeAbilities = {}
        
        for _, entry in ipairs(cooldownData) do
            if type(entry) == "table" and entry.Passive then
                local timeLeft = entry.Time or 0
                local totalTime = entry.Cooldown or entry.MaxTime or 60
                local percentage = math.clamp(timeLeft / totalTime, 0, 1)
                
                local status = timeLeft > 0 and string.format("%s: %ds (%.0f%%)", 
                    entry.Passive, timeLeft, percentage * 100)
                    or string.format("%s: Ready!", entry.Passive)
                
                local color = timeLeft > 0 and Color3.fromHSV(percentage * 0.3, 1, 1) 
                    or Color3.new(0.5, 1, 0.5) 
                
                table.insert(activeAbilities, {
                    text = status,
                    color = color
                })
            end
        end

        if #activeAbilities > 0 then
            local displayText = ""
            for i, ability in ipairs(activeAbilities) do
                displayText = displayText .. ability.text
                if i < #activeAbilities then
                    displayText = displayText .. "\n"
                end
            end
            display.Text = displayText

            display.TextColor3 = #activeAbilities == 1 and activeAbilities[1].color or Color3.new(1, 1, 1)
        else
            display.Text = "No active abilities"
            display.TextColor3 = Color3.new(0.8, 0.8, 0.8)
        end
    else
        display.Text = "Error fetching data"
        display.TextColor3 = Color3.new(1, 0, 0)
    end
end

local function scanAndUpdatePets()
    if not petCooldownEnabled then return end
    
    local currentTime = os.clock()
    if currentTime - lastUpdateTime < UPDATE_INTERVAL then return end
    lastUpdateTime = currentTime

    local currentPets = {}
    for _, pet in ipairs(workspace:GetDescendants()) do
        if pet:IsA("Model") and pet.Name:match("^{.+}$") then
            if pet:FindFirstChild("Humanoid") or pet:FindFirstChildWhichIsA("BasePart") then
                currentPets[pet.Name] = pet
            end
        end
    end
    
    for petName, data in pairs(petCooldownDisplays) do
        if not currentPets[petName] then
            if data.display and data.display.Parent then
                data.display.Parent:Destroy()
            end
            petCooldownDisplays[petName] = nil
        end
    end

    for petName, pet in pairs(currentPets) do
        if not petCooldownDisplays[petName] then
            local display = createPetDisplay(pet)
            if display then
                petCooldownDisplays[petName] = {
                    display = display,
                    pet = pet,
                    lastUpdate = 0
                }
            end
        end
        
        if petCooldownDisplays[petName] then
            updatePetDisplay(petName, petCooldownDisplays[petName].display)
            petCooldownDisplays[petName].lastUpdate = currentTime
        end
    end
end

tab:CreateToggle("Show All Pet Cooldowns", function(enabled)
    petCooldownEnabled = enabled
    
    if enabled then
        scanAndUpdatePets()

        petCooldownConnection = game:GetService("RunService").Heartbeat:Connect(function()
            scanAndUpdatePets()
        end)
        
        createColoredNotification("Pet cooldowns enabled - Showing all pets", "Rarity: Common")
    else
        if petCooldownConnection then
            petCooldownConnection:Disconnect()
            petCooldownConnection = nil
        end
        
        for _, data in pairs(petCooldownDisplays) do
            if data.display and data.display.Parent then
                data.display.Parent:Destroy()
            end
        end
        petCooldownDisplays = {}
        
        createColoredNotification("Pet cooldowns disabled", "Rarity: Common")
    end
end)

tab:CreateToggle("Anti-Kick", function(enabled)
    local namecallHook
    
    if enabled then
        namecallHook = hookmetamethod(game.Players.LocalPlayer, "__namecall", function(...)
            local method = getnamecallmethod()
            if method == "Kick" then
                print("[Anti-Kick] Blocked kick attempt")
                return nil
            end
            return namecallHook(...)
        end)

        if typeof(namecallHook) == "function" then
            print("[Anti-Kick] Protection enabled successfully")
        else
            warn("[Anti-Kick] Failed to create protection!")
            return
        end

        cleanup.connections["AntiKick"] = namecallHook
    else
        if cleanup.connections["AntiKick"] then
            if unhookmetamethod then
                unhookmetamethod(game.Players.LocalPlayer, "__namecall", cleanup.connections["AntiKick"])
            end
            cleanup.connections["AntiKick"] = nil
            print("[Anti-Kick] Protection disabled")
        end
    end
end)

tab:CreateToggle("Anti-Afk", function(enabled)
    if enabled then
        sendNotification("✅ Anti-AFK", "Anti AFK has been enabled.", 5)

        cleanup.connections["antiAfk"] = {}

        for _, connection in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
            local originalState = connection.Enabled
            connection:Disable()

            table.insert(cleanup.connections["antiAfk"], {
                connection = connection,
                originalState = originalState
            })
        end
        
    else
        sendNotification("❌ Anti-AFK", "Anti AFK has been disabled.", 5)
        
        if cleanup.connections["antiAfk"] then
            for _, afkData in ipairs(cleanup.connections["antiAfk"]) do
                if afkData.connection and typeof(afkData.connection) == "userdata" then
                    afkData.connection.Enabled = afkData.originalEnabled
                end
            end
            cleanup.connections["antiAfk"] = nil  
        end
    
    end
end)

local hiddenFruits = {} 

tab:CreateToggle("Hide All Fruits", function(state)
    if state then
        for _, farm in ipairs(workspace.Farm:GetDescendants()) do
            if farm.Name == "Plants_Physical" then
                for _, plant in ipairs(farm:GetChildren()) do
                    if not hiddenFruits[plant] then
                        hiddenFruits[plant] = plant.Parent
                        plant.Parent = game:GetService("ReplicatedStorage")
                    end
                end
            end
        end
        createColoredNotification("All fruits hidden!", "Rarity: Common")
    else
        for plant, originalParent in pairs(hiddenFruits) do
            if plant and originalParent then
                plant.Parent = originalParent
            end
        end
        hiddenFruits = {}
        createColoredNotification("All fruits restored!", "Rarity: Common")
    end
end)

local originalCollisionStates = {} 

local function setFruitsCollision(state)
    for _, farm in ipairs(workspace.Farm:GetDescendants()) do
        if farm.Name == "Plants_Physical" then
            for _, plant in ipairs(farm:GetChildren()) do
                if plant:IsA("BasePart") then
                    if state == false then
                        if not originalCollisionStates[plant] then
                            originalCollisionStates[plant] = plant.CanCollide
                        end
                        plant.CanCollide = false
                    else
                        if originalCollisionStates[plant] ~= nil then
                            plant.CanCollide = originalCollisionStates[plant]
                        end
                    end
                end

                for _, part in ipairs(plant:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if state == false then
                            if not originalCollisionStates[part] then
                                originalCollisionStates[part] = part.CanCollide
                            end
                            part.CanCollide = false
                        else
                            if originalCollisionStates[part] ~= nil then
                                part.CanCollide = originalCollisionStates[part]
                            end
                        end
                    end
                end
            end
        end
    end
end

tab:CreateToggle("No Clip Through Fruits", function(state)
    setFruitsCollision(not state) 
    
    if state then
        createColoredNotification("No Clip enabled - walk through fruits", "Rarity: Common")
    else
        createColoredNotification("No Clip disabled - normal collision", "Rarity: Common")
    end
end)

tab:CreateButton("Sell Equipped Fruit/Pet", function()
    local function isPet(tool)
        return tool:FindFirstChild("Age") or tool:FindFirstChild("KG")
    end

    local equippedPet = nil
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                equippedPet = item
                break
            end
        end
    end

    if not equippedPet then
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                equippedPet = item
                break
            end
        end
    end

    if equippedPet then
        createColoredNotification("Found pet ("..equippedPet.Name..") - selling...", "Rarity: Common")

        if equippedPet.Parent ~= LocalPlayer.Character then
            equippedPet.Parent = LocalPlayer.Character
            task.wait(0.5)
        end

        local args = { equippedPet }
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SellPet_RE"):FireServer(unpack(args))
        task.wait(0.5) 

        if equippedPet and equippedPet.Parent then
            createColoredNotification("Failed to sell pet!", "Rarity: Common")
            return
        end
    end
    
    local equippedFruit = nil
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and not isPet(item) then
                equippedFruit = item
                break
            end
        end
    end

    if equippedFruit then
        local steven = workspace.NPCS:FindFirstChild("Steven")
        if not steven then
            warn("Steven NPC not found!")
            return
        end
        
        local npcHRP = steven:FindFirstChild("HumanoidRootPart")
        if not npcHRP then
            warn("Steven doesn't have HumanoidRootPart!")
            return
        end
        
        local playerChar = LocalPlayer.Character
        if not playerChar then
            warn("Player character not found!")
            return
        end
        
        local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
        if not playerHRP then
            warn("Player doesn't have HumanoidRootPart!")
            return
        end
        
        local originalCFrame = playerHRP.CFrame
        
        playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
        
        task.wait(0.2)
        
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Item"):FireServer()
        
        task.wait(0.2)
        
        playerHRP.CFrame = originalCFrame
        createColoredNotification("Sold equipped fruit: "..equippedFruit.Name, "Rarity: Common")
    elseif not equippedPet then
        createColoredNotification("No equipped pet or fruit found!", "Rarity: Common")
    end
end)

tab:CreateButton("Sell All Fruits", function()
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return
    end
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return
    end
    
    local originalCFrame = playerHRP.CFrame
    
    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    
    task.wait(0.2)
    
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Inventory"):FireServer()
    
    task.wait(0.2)
    
    playerHRP.CFrame = originalCFrame
end)

local autoBuyActive = false
cleanup.loops.buyLoop = nil

local countdownGui = Instance.new("ScreenGui")
countdownGui.Name = "AutoBuyCountdown"
countdownGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 50)
frame.Position = UDim2.new(0.085, 0, 0.4, 0)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
frame.BackgroundTransparency = 0.5
frame.BorderSizePixel = 0
frame.Visible = false
frame.Parent = countdownGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0.4, 0)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Next Auto-Buy In:"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.Gotham
title.TextSize = 14
title.Parent = frame

local timerText = Instance.new("TextLabel")
timerText.Size = UDim2.new(1, 0, 0.6, 0)
timerText.Position = UDim2.new(0, 0, 0.4, 0)
timerText.BackgroundTransparency = 1
timerText.Text = "60s"
timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
timerText.Font = Enum.Font.GothamBold
timerText.TextSize = 18
timerText.Parent = frame

local progressBar = Instance.new("Frame")
progressBar.Size = UDim2.new(1, 0, 0, 3)
progressBar.Position = UDim2.new(0, 0, 1, -3)
progressBar.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
progressBar.BorderSizePixel = 0
progressBar.Parent = frame

local progressFill = Instance.new("Frame")
progressFill.Size = UDim2.new(1, 0, 1, 0)
progressFill.Position = UDim2.new(0, 0, 0, 0)
progressFill.BackgroundColor3 = Color3.fromRGB(220, 20, 60) 
progressFill.BorderSizePixel = 0
progressFill.Parent = progressBar

local function stopBuyLoop()
    if cleanup.loops.buyLoop then
        cleanup.loops.buyLoop = nil
    end
    autoBuyActive = false
    frame.Visible = false
end

local function startBuyLoop()
    cleanup.loops.buyLoop = coroutine.create(function()
        while autoBuyActive do
            frame.Visible = true
            
            autoBuySeeds()
            autoBuyGears()
            autoBuyEggs()
            autoBuyTM()
            
            for i = 60, 1, -1 do
                if not autoBuyActive then break end
                
                timerText.Text = i.."s"
                progressFill.Size = UDim2.new(i/60, 0, 1, 0)
                
                local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(progressFill, tweenInfo, {Size = UDim2.new((i-1)/60, 0, 1, 0)})
                tween:Play()
                
                task.wait(1)
            end
        end
        stopBuyLoop()
    end)
    coroutine.resume(cleanup.loops.buyLoop)
end

tab2:CreateToggle("Auto Buy Seed/Gear/Egg/TM", function(a)
    autoBuyActive = a
    
    if a then
        if not cleanup.loops.buyLoop then
            startBuyLoop()
        end
    else
        stopBuyLoop()
    end
end)

local fruits = {}
local playerPosition = nil
local isRunning = false
local savedTool = nil

local function getFruits()
    fruits = {}
    print("getFruits() called: Scanning backpack and character for fruits.")
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
            table.insert(fruits, item)
            print("Found fruit in backpack: " .. item.Name)
        end
    end
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                table.insert(fruits, item)
                print("Found fruit equipped: " .. item.Name)
            end
        end
    end
    print("Total fruits found: " .. #fruits)
end

local function submitFruit(fruit)
    print("Attempting to submit fruit to Kitsune: " .. fruit.Name)
    fruit.Parent = LocalPlayer.Character
    task.wait(0.2) 
    print("Fruit equipped: " .. fruit.Name)

    local args = {"SubmitToFox"}
    game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))
    print("Fired RemoteEvent: ZenQuestRemoteEvent with args 'SubmitToFox'")

    task.wait(0.5)
    print("Kitsune submit fruit delay complete.")
end

local function shouldSkipItem(itemName)
    local lowerName = itemName:lower()

    local skipPatterns = {
        "staff",        
        "crate",         
        "radar",
        "spray x%d+ %[",  
        "corrupted zen",  
        "corrupted kodama", 
        "corrupted kitsune",
        "seed",
        "tranquil bloom"
    }

    for _, pattern in ipairs(skipPatterns) do
        if lowerName:find(pattern) then
            return true
        end
    end
    return false
end

local function createAutomationToggles()
    automationToggles.kitsune = function(state)
        if state then
            print("Toggle ON: Starting Kitsune automation.")
            if isRunning then
                createColoredNotification("🚫 Another automation is already running. Please turn it off first.", "Rarity: Common")
                return
            end

            if LocalPlayer.Character then
                for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                    if item:IsA("Tool") and not (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                        savedTool = item
                        item.Parent = LocalPlayer.Backpack
                        print("Saved equipped tool: " .. item.Name)
                        break
                    end
                end
            end

            isRunning = true 
            createColoredNotification("✅ Starting Kitsune fruit submission...", "Rarity: Common")
            createColoredNotification("This Automation will skip favorited fruits", "Rarity: Common")

            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                playerPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                print("Player position saved.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found. Cannot save position!", "Rarity: Common")
                isRunning = false
                return
            end

            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-101.82, 3.0, -13.08)
                print("Teleporting to Kitsune.")
                task.wait(1) 
                print("Teleport wait complete.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found for teleport! Stopping.", "Rarity: Common")
                isRunning = false
                return
            end

            local TranquilLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
            local CorruptLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)

            print(string.format("Initial Levels: Tranquil=%s, Corrupt=%s", tostring(TranquilLevel), tostring(CorruptLevel)))

            local validTranquilLevel = type(TranquilLevel) == "number" and TranquilLevel >= 0 and TranquilLevel <= 5
            local validCorruptLevel = type(CorruptLevel) == "number" and CorruptLevel >= 0 and CorruptLevel <= 5

            if not (validTranquilLevel and validCorruptLevel) then
                createColoredNotification("❌ Invalid level values detected! Cannot proceed.", "Rarity: Common")
                print("ERROR: Invalid initial levels. Stopping automation.")
                isRunning = false
                if playerPosition then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                end
                if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                    task.wait(0.5)
                    savedTool.Parent = LocalPlayer.Character
                    savedTool = nil
                end
                return
            end

            getFruits() 
            if #fruits == 0 then
                createColoredNotification("No fruits found to submit for Kitsune.", "Rarity: Common")
                print("No fruits found initially for Kitsune. Stopping automation.")
                isRunning = false
            end

            while isRunning and #fruits > 0 and (TranquilLevel < 5 or CorruptLevel < 5) do
                local fruitsSubmittedInThisPass = 0 

                getFruits()
    
                if #fruits == 0 then
                    print("No more fruits in inventory after re-scan. Stopping Kitsune loop.")
                    break 
                end

                for i = #fruits, 1, -1 do
                    if not isRunning then break end

                    local fruit = fruits[i]
                    if not fruit or not fruit.Parent then
                        print("Kitsune: Fruit no longer exists or has no parent: Removing from list (index " .. i .. ")")
                        table.remove(fruits, i)
                        continue
                    end

                    local fruitName = fruit.Name
                    if shouldSkipItem(fruit.Name) then 
                        createColoredNotification("⏭ Skipping Kitsune: "..fruit.Name, "Rarity: Common")
                        continue
                    end

                    local isTranquil = fruitName:find("Tranquil")
                    local isCorrupt = fruitName:find("Corrupt")

                    print(string.format("Kitsune: Checking fruit: %s (Tranquil: %s, Corrupt: %s). Current Levels: 🌿%d/5 ☠%d/5",
                                        fruitName, tostring(isTranquil), tostring(isCorrupt), TranquilLevel, CorruptLevel))
    
                    local shouldSubmit = false

                    if isTranquil and TranquilLevel < 5 then
                        shouldSubmit = true
                    end
                    if isCorrupt and CorruptLevel < 5 then
                        shouldSubmit = true
                    end

                    print(string.format("Kitsune: Decision for %s: shouldSubmit = %s", fruitName, tostring(shouldSubmit)))

                    if shouldSubmit then
                        if not fruit:GetAttribute("d") then
                            submitFruit(fruit) 
                            fruitsSubmittedInThisPass = fruitsSubmittedInThisPass + 1
                            table.remove(fruits, i)
                            task.wait(1.5) 

                            TranquilLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
                            CorruptLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)

                            if not (type(TranquilLevel) == "number" and TranquilLevel >= 0 and TranquilLevel <= 5) then
                                TranquilLevel = 0
                                print("Kitsune WARNING: TranquilLevel became invalid, resetting to 0.")
                            end
                            if not (type(CorruptLevel) == "number" and CorruptLevel >= 0 and CorruptLevel <= 5) then
                                CorruptLevel = 0
                                print("Kitsune WARNING: CorruptLevel became invalid, resetting to 0.")
                            end

                            createColoredNotification(string.format("Updated Kitsune Levels: 🌿%d/5 ☠%d/5", TranquilLevel, CorruptLevel), "Rarity: Common")
                            print(string.format("Kitsune: Levels after submitting %s: Tranquil=%d, Corrupt=%d", fruitName, TranquilLevel, CorruptLevel))

                            if TranquilLevel == 5 and CorruptLevel == 5 then
                                createColoredNotification("Kitsune Zen levels are maxed out! Stopping submission.", "Rarity: Common")
                                isRunning = false
                                break
                            end
                        else
                            print("Kitsune: Skipping " .. fruitName .. " because it has a 'd' attribute.")
                        end
                    else
                        print("Kitsune: Fruit " .. fruitName .. " not submitted because conditions not met.")
                    end
                end 

                if isRunning and fruitsSubmittedInThisPass == 0 and (#fruits > 0) then
                    print("Kitsune: No suitable fruits found to submit in this pass. Stopping automation.")
                    isRunning = false
                end

                if isRunning then task.wait(1) end 

            end 

            if playerPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                print("Kitsune: Returned to original position.")
            end

            if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                task.wait(0.5)
                savedTool.Parent = LocalPlayer.Character
                savedTool = nil
                print("Kitsune: Restored original tool.")
            end

            if not isRunning then
                createColoredNotification("✅ Kitsune fruit submission finished or stopped.", "Rarity: Common")
            else
                createColoredNotification("✅ Kitsune fruit submission completed!", "Rarity: Common")
            end
            isRunning = false 
            print("Kitsune automation finished.")

        else
            if isRunning then 
                 isRunning = false 
                 createColoredNotification("🔴 Stopped Kitsune fruit submission.", "Rarity: Common")
                 if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                     savedTool.Parent = LocalPlayer.Character
                     savedTool = nil
                     print("Kitsune: Restored tool after manual stop.")
                 end
                 print("Kitsune: Toggle OFF: Automation stopped.")
            end
        end
    end

    automationToggles.tranquil = function(state)
        if state then
            print("Toggle ON: Starting Tranquil NPC automation.")
            if isRunning then
                createColoredNotification("🚫 Another automation is already running. Please turn it off first.", "Rarity: Common")
                return
            end

            if LocalPlayer.Character then
                for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                    if item:IsA("Tool") and not (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                        savedTool = item
                        item.Parent = LocalPlayer.Backpack
                        print("Saved equipped tool: " .. item.Name)
                        break
                    end
                end
            end

            isRunning = true
            createColoredNotification("✅ Starting Tranquil fruit submission...", "Rarity: Common")

            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                playerPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                print("Player position saved.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found. Cannot save position!", "Rarity: Common")
                isRunning = false
                return
            end

            local tranquilNpcPosition = CFrame.new(-73.59021, 4.3999157, -12.1218204)
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = tranquilNpcPosition
                print("Teleporting to Tranquil NPC.")
                task.wait(1) 
                print("Teleport wait complete.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found for teleport! Stopping.", "Rarity: Common")
                isRunning = false
                return
            end

            local submittedFruitCount = 0

            while isRunning do
                local currentTranquilFruits = {}
                for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end
                if LocalPlayer.Character then
                    for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                        if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                            table.insert(currentTranquilFruits, item)
                        end
                    end
                end
                print("Tranquil NPC: Found " .. #currentTranquilFruits .. " potential Tranquil fruits.")

                local submitableTranquilFruits = {}
                for _, fruit in ipairs(currentTranquilFruits) do
                    if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") then 
                        table.insert(submitableTranquilFruits, fruit)
                    else
                        createColoredNotification("⏭ Skipping Tranquil: "..fruit.Name, "Rarity: Common")
                        print("Tranquil NPC: Skipping " .. fruit.Name .. " (either skip pattern or 'd' attribute).")
                    end
                end
                print("Tranquil NPC: Found " .. #submitableTranquilFruits .. " submitable Tranquil fruits.")


                if #submitableTranquilFruits == 0 then
                    createColoredNotification("No more suitable Tranquil fruits found to submit.", "Rarity: Common")
                    print("Tranquil NPC: No suitable Tranquil fruits left. Stopping submission loop.")
                    break 
                end
   
                local fruitToSubmit = submitableTranquilFruits[1]
                print("Tranquil NPC: Attempting to submit fruit: " .. fruitToSubmit.Name)

                fruitToSubmit.Parent = LocalPlayer.Character
                task.wait(0.2)
                print("Tranquil NPC: Fruit equipped: " .. fruitToSubmit.Name)

                local args = {"SubmitAllPlants"}
                game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("ZenQuestRemoteEvent"):FireServer(unpack(args))
                print("Tranquil NPC: Fired RemoteEvent: ZenQuestRemoteEvent with args 'SubmitAllPlants'")

                submittedFruitCount = submittedFruitCount + 1
                createColoredNotification(string.format("Submitted Tranquil fruit #%d", submittedFruitCount), "Rarity: Common")

                task.wait(1.0)
            end

            if playerPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                print("Tranquil NPC: Returned to original position.")
            end

            if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                task.wait(0.5)
                savedTool.Parent = LocalPlayer.Character
                savedTool = nil
                print("Tranquil NPC: Restored original tool.")
            end

            createColoredNotification("✅ Tranquil fruit submission completed!", "Rarity: Common")
            isRunning = false
            print("Tranquil NPC automation finished.")

        else
            if isRunning then
                isRunning = false 
                createColoredNotification("🔴 Stopped Tranquil fruit submission.", "Rarity: Common")
                if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                    savedTool.Parent = LocalPlayer.Character
                    savedTool = nil
                    print("Tranquil NPC: Restored tool after manual stop.")
                end
                print("Tranquil NPC: Toggle OFF: Automation stopped.")
            end
        end
    end

    tab2:CreateToggle("Auto Give Fruits to Kitsune", function(state)
        automationToggles.kitsune(state)
    end)

    tab2:CreateToggle("Auto Give Fruits to Tranquil NPC", function(state)
        automationToggles.tranquil(state)
    end)
end

createAutomationToggles()

local selectedMutation = nil
local autoPickupActive = false

local IGNORED_ATTRIBUTES = {
    "DoneGrowTime",
    "GrowRateMulti",
    "MaxAge",
    "FruitSpawnIndex",
    "FruitVersion",
    "WeightMulti",
    "SetVariant",
    "IsOutlined",
    "Inspected",
    "SkipRotation",
    "OfflineGrowthTarget",
    "WaitForPlantGenerated"
}

local function scanForMutations()
    local mutationList = {}
    
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return mutationList end
    end

    local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
    if plantsPhysical then
        for _, plant in pairs(plantsPhysical:GetChildren()) do
            local fruitsFolder = plant:FindFirstChild("Fruits")
            if fruitsFolder then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    for attrName, _ in pairs(fruit:GetAttributes()) do
                        if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                            table.insert(mutationList, attrName)
                        end
                    end
                end
            else
                for attrName, _ in pairs(plant:GetAttributes()) do
                    if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                        table.insert(mutationList, attrName)
                    end
                end
            end
        end
    end
    
    return mutationList
end

local mutationDropdown = tab2:CreateDDO("Select Mutation", {}, function(selected)
    selectedMutation = selected
end)

task.spawn(function()
    while true do
        local mutations = scanForMutations() 
        mutationDropdown:SetOptions(mutations)
        wait(30) 
    end
end)

local function collectFruitsWithMutation()
    while autoPickupActive and selectedMutation do
        if not playerFarm then
            playerFarm = findPlayerFarm()
            if not playerFarm then break end
        end

        local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
        if plantsPhysical then
            for _, plant in pairs(plantsPhysical:GetChildren()) do
                local function scanFruitModel(model)
                    if model:GetAttribute(selectedMutation) then
                        local prompt = model:FindFirstChildWhichIsA("ProximityPrompt")
                        if not prompt then
                            for _, descendant in pairs(model:GetDescendants()) do
                                if descendant:IsA("ProximityPrompt") then
                                    prompt = descendant
                                    break
                                end
                            end
                        end

                        if prompt then
                            local char = LocalPlayer.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                local hrp = char.HumanoidRootPart
                                local originalPos = hrp.CFrame

                                hrp.CFrame = model:GetPivot() * CFrame.new(0, 0, -2)

                                task.wait(0.2)
                                fireproximityprompt(prompt)

                                task.wait(0.1)
                                hrp.CFrame = originalPos
                            end
                        end
                    end
                end

                local fruitsFolder = plant:FindFirstChild("Fruits")
                if fruitsFolder then
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        scanFruitModel(fruit)
                        for _, subPart in pairs(fruit:GetDescendants()) do
                            if subPart:IsA("Model") or subPart:IsA("BasePart") then
                                scanFruitModel(subPart)
                            end
                        end
                    end
                else
                    scanFruitModel(plant)
                end
            end
        end
        
        task.wait(0.5)
    end
end

tab2:CreateToggle("Auto Pickup Fruits with mutation", function(state)
    autoPickupActive = state
    if state then
        if not selectedMutation then
            sendNotification("Pickup Error", "Select a mutation first!", 5)
            return
        end
        task.spawn(collectFruitsWithMutation)
        sendNotification("Auto Pickup", "Started collecting "..selectedMutation, 5)
    else
        sendNotification("Auto Pickup", "Stopped collecting", 3)
    end
end)

local function isPet(tool)
    if tool.Name:find("Age") or tool.Name:find("KG") then
        return true
    end

    if tool:GetAttribute("PetId") or tool:GetAttribute("PetRarity") then
        return true
    end
    
    if tool:HasTag("Pet") or tool:HasTag("Collectable") then
        return true
    end
    
    return false
end

local function shouldSkipPet(petName)
    local highTierPets = {
        "Raccoon", "Dragonfly", "Butterfly", "Spinosaurus", "T-Rex", "Corrupted Kitsune",
        "Kitsune", "Queen Bee", "Disco Bee", "Red Fox", "Raiju", "Koi", "Kappa",
        "Mimic Octopus", "Bear Bee", "Pack Bee", "Tanchozuru", "Corrupted Kodama",
        "Triceratops", "Moon Cat", "Silver Monkey", "Blood Hedgehog",
        "Bald Eagle", "Mole", "Football", "Hamster", "Chicken Zombie", "Firefly",
        "Owl", "Golden Bee", "Echo Frog", "Cooked Owl", "Blood Kiwi", "Night Owl",
        "Hyacinth Macaw", "Axolotl", "Dilophosaurus", "Ankylosaurus", "Pterodactyl",
        "Brontosaurus", "Fennec Fox", "Blood Owl", "Red Dragon", "Moth"
    }
    
    for _, highTierPet in ipairs(highTierPets) do
        if petName:find(highTierPet) then
            return true
        end
    end
    return false
end

local function autoSellPets()
    local hasAnyPets = false
    local hasUnfavoritedPets = false

    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and isPet(item) then
            hasAnyPets = true
            if not item:GetAttribute("d") and not shouldSkipPet(item.Name) then
                hasUnfavoritedPets = true
            end
        end
    end

    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                hasAnyPets = true
                if not item:GetAttribute("d") and not shouldSkipPet(item.Name) then
                    hasUnfavoritedPets = true
                end
            end
        end
    end
    
    if not hasAnyPets then
        createColoredNotification("You don't have any pets to sell!", "Rarity: Common")
        return
    end
    
    if not hasUnfavoritedPets then
        createColoredNotification("All your pets are favorited or high-tier! Unfavorite them to sell.", "Rarity: Common")
        return
    end

    local originalPos
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        originalPos = LocalPlayer.Character.HumanoidRootPart.CFrame
    end

    local sellNPC = workspace.NPCS:FindFirstChild("Steven")
    if not sellNPC then
        createColoredNotification("Couldn't find the sell NPC!", "Rarity: Common")
        return
    end
    
    local npcHRP = sellNPC:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        createColoredNotification("Sell NPC doesn't have HRP!", "Rarity: Common")
        return
    end

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3)
        task.wait(1)
    else
        createColoredNotification("Couldn't teleport to sell NPC!", "Rarity: Common")
        return
    end

    local petsSold = 0
    
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                if not item:GetAttribute("d") and not shouldSkipPet(item.Name) then
                    local args = {item}
                    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SellPet_RE"):FireServer(unpack(args))
                    petsSold = petsSold + 1
                    task.wait(0.5)
                end
            end
        end
    end

    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and isPet(item) then
            if not item:GetAttribute("d") and not shouldSkipPet(item.Name) then
                item.Parent = LocalPlayer.Character
                task.wait(0.5)

                local args = {item}
                game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SellPet_RE"):FireServer(unpack(args))
                petsSold = petsSold + 1
                task.wait(0.5)
            end
        end
    end

    if originalPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
        task.wait(0.5)
    end
    
    if petsSold > 0 then
        createColoredNotification(string.format("Sold %d pets successfully!", petsSold), "Rarity: Common")
    else
        createColoredNotification("No eligible pets were sold.", "Rarity: Common")
    end
end

tab2:CreateButton("Auto Sell Unfavorited Pets", function()
    autoSellPets()
end)

tab3:CreateButton("Sprinkler Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Phynomie/tg/refs/heads/main/script.lua"))()
end)

local targetFruits = {"Serenity", "Zenflare", "Soft Sunshine", "Maple Apple", "Lucky Bamboo", "Sakura Bush"}
local maxBackpackItems = nil
local fruitAutomationActive = false
local loopCount = 0
local blacklistedFruits = {} 
local tranquilAutomationActive = false

local playerBackpackLimits = {
    ["default"] = nil
}

local function sellAllFruits()
    if not tranquilAutomationActive then return false end 
    
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return false
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return false
    end
    
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return false
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return false
    end
    
    local originalCFrame = playerHRP.CFrame

    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    task.wait(0.5)

    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Inventory"):FireServer()
    createColoredNotification("Sold all remaining fruits", "Rarity: Common")
    task.wait(0.5)

    playerHRP.CFrame = originalCFrame
    return true
end

local function countBackpackItems()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    return backpack and #backpack:GetChildren() or 0
end

local function setBackpackLimit()
    local currentCount = countBackpackItems()

    if playerBackpackLimits["default"] == nil then
        playerBackpackLimits["default"] = currentCount
    end

    maxBackpackItems = playerBackpackLimits["default"]
    
    createColoredNotification(string.format("Backpack slots: %d/%d", countBackpackItems(), maxBackpackItems), "Rarity: Common")
end

local function getAvailableSpace()
    return maxBackpackItems - countBackpackItems()
end

local function collectTargetFruits()
    setBackpackLimit()

    while tranquilAutomationActive do
        loopCount = loopCount + 1
        local availableSpace = getAvailableSpace()
        
        createColoredNotification(string.format("Starting AFK loop #%d (%d/%d slots used)", 
            loopCount, countBackpackItems(), maxBackpackItems), "Rarity: Common")

        local originalPos
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            originalPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        end
        
        while tranquilAutomationActive and getAvailableSpace() > 0 do
            if not playerFarm then playerFarm = findPlayerFarm() end
            if not playerFarm then task.wait(5); continue end

            local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
            if not plantsPhysical then task.wait(1); continue end

            for _, plant in pairs(plantsPhysical:GetChildren()) do
                if not getAvailableSpace() <= 0 then break end
                
                local fruitsFolder = plant:FindFirstChild("Fruits") or plant
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if not getAvailableSpace() <= 0 then break end

                    local isTarget = false
                    for _, target in pairs(targetFruits) do
                        if fruit.Name:find(target) and fruit:GetAttribute("DoneGrowTime") then
                            isTarget = true
                            break
                        end
                    end
                    if not isTarget then continue end

                    local prompt
                    for _, descendant in pairs(fruit:GetDescendants()) do
                        if descendant:IsA("ProximityPrompt") then
                            prompt = descendant
                            break
                        end
                    end
                    if not prompt then continue end

                    local char = LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        hrp.CFrame = fruit:GetPivot() * CFrame.new(0, 0, -2.5)
                        task.wait(0.15)
                        fireproximityprompt(prompt)
                        createColoredNotification("Collected "..fruit.Name..string.format(" (%d/%d free)", 
                            getAvailableSpace(), maxBackpackItems), "Rarity: Common")
                        task.wait(0.35)
                    end
                end
            end
            task.wait(0.5)
        end

        if not tranquilAutomationActive then break end 

        if automationToggles.tranquil then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-73.59021, 4.3999157, -12.1218204)
                task.wait(1) 
            end
            
            local tranquilSuccess = false
            while tranquilAutomationActive and not tranquilSuccess do
                local currentTranquilFruits = {}
                for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end
                
                if LocalPlayer.Character then
                    for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                        if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                            table.insert(currentTranquilFruits, item)
                        end
                    end
                end

                local submitableTranquilFruits = {}
                for _, fruit in ipairs(currentTranquilFruits) do
                    if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") and not blacklistedFruits[fruit] then
                        table.insert(submitableTranquilFruits, fruit)
                    end
                end
                
                if #submitableTranquilFruits == 0 then
                    tranquilSuccess = true
                    break
                end

                local fruitToSubmit = submitableTranquilFruits[1]
                fruitToSubmit.Parent = LocalPlayer.Character
                task.wait(0.5)

                local args = {"SubmitAllPlants"}
                game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))

                local startTime = os.clock()
                while os.clock() - startTime < 2 do
                    if fruitToSubmit.Parent ~= LocalPlayer.Character then
                        break 
                    end
                    task.wait(0.1)
                end

                if fruitToSubmit.Parent == LocalPlayer.Character then
                    blacklistedFruits[fruitToSubmit] = true
                    fruitToSubmit.Parent = LocalPlayer.Backpack
                end
                
                task.wait(1.5)
            end

            if originalPos then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
                task.wait(0.5)
            end
        end

        if not tranquilAutomationActive then break end

        createColoredNotification("Selling remaining fruits...", "Rarity: Common")
        sellAllFruits()
        
        if not tranquilAutomationActive then break end
        
        createColoredNotification(string.format("Completed AFK loop #%d", loopCount), "Rarity: Common")
        task.wait(3)
    end
    
    while fruitAutomationActive do
        loopCount = loopCount + 1
        local availableSpace = getAvailableSpace()
        
        createColoredNotification(string.format("Starting AFK loop #%d (%d/%d slots used)", 
            loopCount, countBackpackItems(), maxBackpackItems), "Rarity: Common")

        local originalPos
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            originalPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        end
        
        while fruitAutomationActive and getAvailableSpace() > 0 do
            if not playerFarm then playerFarm = findPlayerFarm() end
            if not playerFarm then task.wait(5); continue end

            local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
            if not plantsPhysical then task.wait(1); continue end

            for _, plant in pairs(plantsPhysical:GetChildren()) do
                if not fruitAutomationActive or getAvailableSpace() <= 0 then break end
                
                local fruitsFolder = plant:FindFirstChild("Fruits") or plant
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if not fruitAutomationActive or getAvailableSpace() <= 0 then break end

                    local isTarget = false
                    for _, target in pairs(targetFruits) do
                        if fruit.Name:find(target) and fruit:GetAttribute("DoneGrowTime") then
                            isTarget = true
                            break
                        end
                    end
                    if not isTarget then continue end

                    local prompt
                    for _, descendant in pairs(fruit:GetDescendants()) do
                        if descendant:IsA("ProximityPrompt") then
                            prompt = descendant
                            break
                        end
                    end
                    if not prompt then continue end

                    local char = LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        hrp.CFrame = fruit:GetPivot() * CFrame.new(0, 0, -2.5)
                        task.wait(0.15)
                        fireproximityprompt(prompt)
                        createColoredNotification("Collected "..fruit.Name..string.format(" (%d/%d free)", 
                            getAvailableSpace(), maxBackpackItems), "Rarity: Common")
                        task.wait(0.35)
                    end
                end
            end
            task.wait(0.5)
        end

        if not fruitAutomationActive then break end 

        createColoredNotification("Starting Kitsune submission...", "Rarity: Common")
        if automationToggles.kitsune and fruitAutomationActive then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-101.82, 3.0, -13.08)
                task.wait(1) 
            end

            local kitsuneSuccess = false
            while fruitAutomationActive and not kitsuneSuccess do
                local TranquilLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
                local CorruptLevel = tonumber(workspace.ZenEvent["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)
                
                if TranquilLevel == 5 and CorruptLevel == 5 then
                    kitsuneSuccess = true
                    break
                end

                getFruits()
                local submittedAny = false
                
                for i = #fruits, 1, -1 do
                    if not fruitAutomationActive then break end
                    
                    local fruit = fruits[i]
                    if not fruit or not fruit.Parent then
                        table.remove(fruits, i)
                        continue
                    end
                    
                    local fruitName = fruit.Name
                    if shouldSkipItem(fruit.Name) or fruit:GetAttribute("d") or blacklistedFruits[fruit] then
                        continue
                    end

                    local isTranquil = fruitName:find("Tranquil")
                    local isCorrupt = fruitName:find("Corrupt")
                    
                    if (isTranquil and TranquilLevel < 5) or (isCorrupt and CorruptLevel < 5) then
                        if safeSubmitToKitsune(fruit) then
                            submittedAny = true
                            table.remove(fruits, i)
                            task.wait(1)
                            break 
                        end
                    end
                end
                
                if not submittedAny then
                    kitsuneSuccess = true
                end
                
                task.wait(1)
            end
            if originalPos then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
                task.wait(0.5)
            end
        end

        if not fruitAutomationActive then break end 

        if automationToggles.tranquil and fruitAutomationActive then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-73.59021, 4.3999157, -12.1218204)
                task.wait(1) 
            end
            
            local tranquilSuccess = false
            while fruitAutomationActive and not tranquilSuccess do
                local currentTranquilFruits = {}

                if LocalPlayer.Character then
                    for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                        if item:IsA("Tool") then
                            item.Parent = LocalPlayer.Backpack
                        end
                    end
                end

                for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end

                local submitableTranquilFruits = {}
                for _, fruit in ipairs(currentTranquilFruits) do
                    if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") and not blacklistedFruits[fruit] then
                        table.insert(submitableTranquilFruits, fruit)
                    end
                end
                
                if #submitableTranquilFruits == 0 then
                    tranquilSuccess = true
                    break
                end

                local fruitToSubmit = submitableTranquilFruits[1]
                fruitToSubmit.Parent = LocalPlayer.Character
                task.wait(0.5)

                local args = {"SubmitAllPlants"}
                game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))

                local startTime = os.clock()
                while os.clock() - startTime < 2 do
                    if fruitToSubmit.Parent ~= LocalPlayer.Character then
                        break 
                    end
                    task.wait(0.1)
                end

                if fruitToSubmit.Parent == LocalPlayer.Character then
                    blacklistedFruits[fruitToSubmit] = true
                    fruitToSubmit.Parent = LocalPlayer.Backpack
                end
                
                task.wait(1.5)
            end

            if originalPos then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
                task.wait(0.5)
            end
        end

        if not fruitAutomationActive then break end

        createColoredNotification("Selling remaining fruits...", "Rarity: Common")
        sellAllFruits()
        
        if not fruitAutomationActive then break end
        
        createColoredNotification(string.format("Completed AFK loop #%d", loopCount), "Rarity: Common")
        task.wait(3)
    end

    blacklistedFruits = {} 
    createColoredNotification("AFK farming loop stopped", "Rarity: Common")
end

local function collectTargetFruits3()
    if not playerFarm then playerFarm = findPlayerFarm() end
    if not playerFarm then 
        createColoredNotification("Farm not found!", "Rarity: Common")
        return false 
    end

    local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
    if not plantsPhysical then 
        createColoredNotification("No plants found in farm", "Rarity: Common")
        return false 
    end

    local availableFruits = {}
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        local fruitsFolder = plant:FindFirstChild("Fruits") or plant
        for _, fruit in pairs(fruitsFolder:GetChildren()) do
            if not fruit:GetAttribute("d") and fruit:GetAttribute("DoneGrowTime") then
                local weight = fruit:FindFirstChild("Weight") and fruit.Weight.Value or 0
                table.insert(availableFruits, {
                    fruit = fruit,
                    weight = weight,
                    model = fruit
                })
            end
        end
    end

    table.sort(availableFruits, function(a, b) 
        return a.weight > b.weight 
    end)

    local collectedAny = false
    for _, data in ipairs(availableFruits) do
        if getAvailableSpace() <= 0 then break end

        local fruit = data.model
        local prompt
        for _, descendant in pairs(fruit:GetDescendants()) do
            if descendant:IsA("ProximityPrompt") then
                prompt = descendant
                break
            end
        end

        if prompt and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            hrp.CFrame = fruit:GetPivot() * CFrame.new(0, 0, -2.5)
            task.wait(0.15)
            fireproximityprompt(prompt)
            createColoredNotification("Collected "..fruit.Name.." ("..string.format("%.2f", data.weight).."kg)", "Rarity: Common")
            collectedAny = true
            task.wait(0.35)
        end
    end

    if not collectedAny then
        createColoredNotification("No collectable fruits found", "Rarity: Common")
    end

    return collectedAny
end

local function tranquilOnlyLoop()
    setBackpackLimit() 
    
    while tranquilAutomationActive do
        loopCount = loopCount + 1
        local availableSpace = getAvailableSpace()
        
        createColoredNotification(string.format("Starting AFK loop #%d (%d/%d slots used)", 
            loopCount, countBackpackItems(), maxBackpackItems), "Rarity: Common")

        local originalPos
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            originalPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        end
        
        while tranquilAutomationActive and getAvailableSpace() > 0 do
            if not playerFarm then playerFarm = findPlayerFarm() end
            if not playerFarm then task.wait(5); continue end

            local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
            if not plantsPhysical then task.wait(1); continue end

            for _, plant in pairs(plantsPhysical:GetChildren()) do
                if not tranquilAutomationActive or getAvailableSpace() <= 0 then break end
                
                local fruitsFolder = plant:FindFirstChild("Fruits") or plant
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    if not tranquilAutomationActive or getAvailableSpace() <= 0 then break end

                    local isTarget = false
                    for _, target in pairs(targetFruits) do
                        if fruit.Name:find(target) and fruit:GetAttribute("DoneGrowTime") then
                            isTarget = true
                            break
                        end
                    end
                    if not isTarget then continue end

                    local prompt
                    for _, descendant in pairs(fruit:GetDescendants()) do
                        if descendant:IsA("ProximityPrompt") then
                            prompt = descendant
                            break
                        end
                    end
                    if not prompt then continue end

                    local char = LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        hrp.CFrame = fruit:GetPivot() * CFrame.new(0, 0, -2.5)
                        task.wait(0.15)
                        fireproximityprompt(prompt)
                        createColoredNotification("Collected "..fruit.Name..string.format(" (%d/%d free)", 
                            getAvailableSpace(), maxBackpackItems), "Rarity: Common")
                        task.wait(0.35)
                    end
                end
            end
            task.wait(0.5)
        end

        if not tranquilAutomationActive then break end

        createColoredNotification("Starting Tranquil submission...", "Rarity: Common")

        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-73.59021, 4.3999157, -12.1218204)
            task.wait(1)
        end

        local tranquilSuccess = false
        while tranquilAutomationActive and not tranquilSuccess do
            local currentTranquilFruits = {}

            for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                    table.insert(currentTranquilFruits, item)
                end
            end
            
            if LocalPlayer.Character then
                for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end
            end
            local submitableTranquilFruits = {}
            for _, fruit in ipairs(currentTranquilFruits) do
                if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") and not blacklistedFruits[fruit] then
                    table.insert(submitableTranquilFruits, fruit)
                end
            end
            
            if #submitableTranquilFruits == 0 then
                tranquilSuccess = true
                break
            end

            local fruitToSubmit = submitableTranquilFruits[1]
            fruitToSubmit.Parent = LocalPlayer.Character
            task.wait(0.5)

            local args = {"SubmitAllPlants"}
            game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))

            local startTime = os.clock()
            while os.clock() - startTime < 2 do
                if fruitToSubmit.Parent ~= LocalPlayer.Character then
                    break 
                end
                task.wait(0.1)
            end

            if fruitToSubmit.Parent == LocalPlayer.Character then
                blacklistedFruits[fruitToSubmit] = true
                fruitToSubmit.Parent = LocalPlayer.Backpack
            end
            
            task.wait(1.5)
        end

        if originalPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
            task.wait(0.5)
        end

        if not tranquilAutomationActive then break end

        createColoredNotification("Checking for leftover fruits...", "Rarity: Common")
        
        task.wait(1)  

        local shouldSell = false
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") and not item.Name:find("Tranquil") then
                shouldSell = true
                break
            end
        end

        if shouldSell then
            createColoredNotification("Selling remaining fruits...", "Rarity: Common")
            sellAllFruits()
        else
            createColoredNotification("No leftover fruits to sell", "Rarity: Common")
        end

        if originalPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
            task.wait(0.5)
        end

        if not tranquilAutomationActive then break end
        
        createColoredNotification(string.format("Completed AFK loop #%d", loopCount), "Rarity: Common")
        task.wait(3)
    end
    
    blacklistedFruits = {} 
    createColoredNotification("Tranquil AFK loop stopped", "Rarity: Common")
end

tab2:CreateToggle("AFK Fruit Farm (Tranquil Only)", function(state)
    tranquilAutomationActive = state
    if state then
        task.spawn(tranquilOnlyLoop)
    else
        createColoredNotification("Stopping AFK farming loop...", "Rarity: Common")
        playerBackpackLimits["default"] = nil
    end
end)

local cookAutomationActive = false
local cookingLoopThread = nil
local cookingPotLocation = CFrame.new(-104.675011, 4.40011406, -11.0908785)
local npcLocation = CFrame.new(-96.2885437, 4.39998388, -9.68481731, -0.031258896, 2.55506354e-08, -0.999511302, -1.01894253e-08, 1, 2.58817927e-08, 0.999511302, 1.09934826e-08, -0.031258896)

local RECIPES = {
    ["Sandwich"] = {
        ingredients = {"Tomato", "Tomato", "Corn"},
        rarity = "Uncommon"
    },
    ["Pie"] = {
        ingredients = {
            ["Prismatic"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Bone Blossom", "Pumpkin"},
            ["Divine"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Sugar Apple", "Pumpkin"},
            ["Mythical"] = {"Corn", "Coconut", "Coconut", "Coconut", "Mango"},
            ["Legendary"] = {"Corn", "Coconut"},
            ["Rare"] = {"Pumpkin", "Apple"}
        },
        rarity = "Varies"
    },
    ["Burger"] = {
        ingredients = {
            ["Divine"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Corn", "Tomato"},
            ["Mythical"] = {"Pepper", "Corn", "Tomato", "Bone Blossom", "Beanstalk"},
            ["Legendary"] = {"Pepper", "Corn", "Tomato"}
        },
        rarity = "Varies"
    },
    ["Hotdog"] = {
        ingredients = {
            ["Prismatic"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Bone Blossom", "Corn"},
            ["Divine"] = {"Ember Lily", "Ember Lily", "Ember Lily", "Ember Lily", "Corn"},
            ["Mythical"] = {"Corn", "Ember Lily"},
            ["Legendary"] = {"Pepper", "Corn"}
        },
        rarity = "Varies"
    },
    ["Waffle"] = {
        ingredients = {
            ["Divine"] = {"Sugar Apple", "Coconut"},
            ["Mythical"] = {"Tranquil Bloom", "Starfruit", "Coconut"},
            ["Legendary"] = {"Pumpkin", "Watermelon"},
            ["Rare"] = {"Pumpkin", "Sugar Apple"}
        },
        rarity = "Varies"
    },
    ["Salad"] = {
        ingredients = {
            ["Prismatic"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Bone Blossom", "Tomato"},
            ["Divine"] = {"Sugar Apple", "Sugar Apple", "Sugar Apple", "Pepper", "Pineapple"},
            ["Mythical"] = {"Giant Pinecone", "Tomato"},
            ["Rare"] = {"Tomato", "Tomato"}
        },
        rarity = "Varies"
    },
    ["Sushi"] = {
        ingredients = {
            ["Divine"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Bamboo", "Corn"},
            ["Mythical"] = {"Sugar Apple", "Sugar Apple", "Sugar Apple", "Bamboo", "Corn"},
            ["Legendary"] = {"Pepper", "Coconut", "Bamboo", "Corn"},
            ["Rare"] = {"Bamboo", "Bamboo", "Bamboo", "Bamboo", "Corn"}
        },
        rarity = "Varies"
    },
    ["Ice Cream"] = {
        ingredients = {
            ["Prismatic"] = {"Banana", "Sugar Apple", "Bone Blossom", "Bone Blossom", "Bone Blossom"},
            ["Legendary"] = {"Banana", "Banana"},
            ["Mythical"] = {"Banana", "Sugar Apple"},
            ["Uncommon"] = {"Blueberry", "Corn"}
        },
        rarity = "Varies"
    },
    ["Donut"] = {
        ingredients = {
            ["Uncommon"] = {"Corn", "Blueberry", "Strawberry"},
            ["Common"] = {"Strawberry", "Tomato", "Apple"}
        },
        rarity = "Varies"
    },
    ["Pizza"] = {
        ingredients = {
            ["Divine"] = {"Sugar Apple", "Bone Blossom", "Corn"},
            ["Mythical"] = {"Tomato", "Corn", "Pepper", "Sugar Apple", "Sugar Apple"},
            ["Legendary"] = {"Corn", "Corn", "Apple", "Apple", "Pepper"},
            ["Rare"] = {"Banana", "Tomato"}
        },
        rarity = "Varies"
    },
    ["Cake"] = {
        ingredients = {
            ["Prismatic"] = {"Bone Blossom", "Bone Blossom", "Bone Blossom", "Sugar Apple", "Banana"},
            ["Divine"] = {"Banana", "Kiwi", "Bone Blossom", "Bone Blossom", "Bone Blossom"},
            ["Mythical"] = {"Sugar Apple", "Sugar Apple", "Corn", "Corn"},
            ["Legendary"] = {"Kiwi", "Kiwi", "Banana", "Banana"},
            ["Rare"] = {"Blueberry", "Grape", "Apple", "Corn"},
            ["Uncommon"] = {"Corn", "Corn", "Strawberry", "Strawberry"}
        },
        rarity = "Varies"
    }
}

local function getCurrentCraving()
    local success, cravingBubble = pcall(function()
        return workspace.Interaction.UpdateItems.CookingEvent.CookingEventModel.PigChefFolder.PigChef.Cravings.CravingThoughtBubblePart
    end)
    if not success or not cravingBubble then return nil end
    
    local cravingText = cravingBubble.CravingBillboard.BG.CravingTextLabel.Text
    for foodName in pairs(RECIPES) do
        if cravingText:lower():find(foodName:lower()) then
            return foodName
        end
    end
    return nil
end

local function countInventoryItems()
    local inventory = {}

    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            local baseName = item.Name:gsub("%b[]", ""):gsub("%s+$", "")
            inventory[baseName] = (inventory[baseName] or 0) + 1
        end
    end

    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                local baseName = item.Name:gsub("%b[]", ""):gsub("%s+$", "")
                inventory[baseName] = (inventory[baseName] or 0) + 1
            end
        end
    end
    
    return inventory
end

local function getWeightFromName(itemName)
    local weightStr = itemName:match("%[(.-)kg%]")
    return weightStr and tonumber(weightStr) or 0
end

local function getInventoryWithWeights()
    local inventory = {}

    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            local baseName = item.Name:gsub("%s*%b[]", ""):gsub("%s+$", "")
            inventory[baseName] = inventory[baseName] or {}
            table.insert(inventory[baseName], {
                item = item,
                weight = item:FindFirstChild("Weight") and item.Weight.Value or getWeightFromName(item.Name)
            })
        end
    end

    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                local baseName = item.Name:gsub("%s*%b[]", ""):gsub("%s+$", "")
                inventory[baseName] = inventory[baseName] or {}
                table.insert(inventory[baseName], {
                    item = item,
                    weight = item:FindFirstChild("Weight") and item.Weight.Value or getWeightFromName(item.Name)
                })
            end
        end
    end

    for _, items in pairs(inventory) do
        table.sort(items, function(a, b) return a.weight > b.weight end)
    end
    
    return inventory
end

local function findBestRecipe(foodName)
    local inventory = getInventoryWithWeights()
    local recipeData = RECIPES[foodName]
    
    if not recipeData then 
        return nil 
    end

    local function getBaseName(fullName)
        return fullName:gsub("%s*%b[]", ""):gsub("%s+$", "")
    end

    local rarities = {"Prismatic", "Divine", "Mythical", "Legendary", "Rare", "Uncommon", "Common"}
    
    for _, rarity in ipairs(rarities) do
        local ingredients = recipeData.ingredients[rarity] or (rarity == "Common" and recipeData.ingredients)
        if ingredients then
            local canMake = true
            local selectedItems = {}

            for _, ing in ipairs(ingredients) do
                local hasIngredient = false
                for itemName, items in pairs(inventory) do
                    if getBaseName(itemName) == ing then
                        hasIngredient = true
                        break
                    end
                end
                if not hasIngredient then
                    canMake = false
                    break
                end
            end

            if canMake then
                for _, ing in ipairs(ingredients) do
                    local heaviestItem = nil
                    local maxWeight = 0

                    for itemName, items in pairs(inventory) do
                        if getBaseName(itemName) == ing then
                            if items[1].weight > maxWeight then
                                heaviestItem = items[1].item
                                maxWeight = items[1].weight
                            end
                        end
                    end

                    if heaviestItem then
                        table.insert(selectedItems, heaviestItem)
                    else
                        canMake = false
                        break
                    end
                end
            end

            if canMake then
                return {
                    items = selectedItems,
                    rarity = rarity,
                    priority = recipeData.priority
                }
            end
        end
    end
    
    return nil 
end

local function submitItems(items)
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                item.Parent = LocalPlayer.Backpack
                task.wait(0.1)
            end
        end
    end

    for _, item in ipairs(items) do
        if not item or not item.Parent then return false end
        
        item.Parent = LocalPlayer.Character
        task.wait(0.3)
        
        local args = {"SubmitHeldPlant"}
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CookingPotService_RE"):FireServer(unpack(args))
        task.wait(0.5)
        
        if item.Parent == LocalPlayer.Character then
            item.Parent = LocalPlayer.Backpack
        end
    end
    
    return true
end

local function cookBestPossible()
    local currentCraving = getCurrentCraving()
    if not currentCraving then
        createColoredNotification("No valid craving detected!", "Rarity: Common")
        return false
    end
    
    createColoredNotification("Current craving: "..currentCraving, "Rarity: Common")
    
    local bestRecipe = findBestRecipe(currentCraving)
    if not bestRecipe then
        createColoredNotification("No matching ingredients for "..currentCraving, "Rarity: Common")
        return false
    end
    
    createColoredNotification(string.format("Making %s (%s) with heaviest available fruits", 
        currentCraving, bestRecipe.rarity), "Rarity: Common")
    
    if submitItems(bestRecipe.items) then
        game:GetService("ReplicatedStorage").GameEvents.CookingPotService_RE:FireServer("CookBest")
        createColoredNotification("Started cooking "..currentCraving.." ("..bestRecipe.rarity..")", "Rarity: Common")
        return true
    else
        createColoredNotification("Failed to submit ingredients!", "Rarity: Common")
        return false
    end
end

local function getCurrentCookingTime()
    local cookingPot = workspace.Interaction.UpdateItems.CookingEvent.CookingEventModel
    if not cookingPot then return nil end
    
    local timerDisplay = cookingPot.IngredientsBoard.CookTimeDisplay.Face.SurfaceGui.TimeDisplayFrame.TimeLabel
    if not timerDisplay then return nil end
    
    return timerDisplay.Text
end

local function parseTimeToSeconds(timeStr)
    if (timeStr == "Ready" or timeStr:find("00:00")) then return 0 end
    
    local minutes, seconds = timeStr:match("(%d+):(%d+)")
    if not minutes then return nil end
    
    return (tonumber(minutes) * 60 + tonumber(seconds))
end

local function getCookingPotStatus()
    local success, result = pcall(function()
        local pot = workspace:FindFirstChild("Interaction") and
                   workspace.Interaction:FindFirstChild("UpdateItems") and
                   workspace.Interaction.UpdateItems:FindFirstChild("CookingEvent") and
                   workspace.Interaction.UpdateItems.CookingEvent:FindFirstChild("CookingEventModel")
        
        if not pot then
            warn("Cooking pot model not found!")
            return nil
        end
        
        local timerGui = pot:FindFirstChild("IngredientsBoard") and
                        pot.IngredientsBoard:FindFirstChild("CookTimeDisplay") and
                        pot.IngredientsBoard.CookTimeDisplay:FindFirstChild("Face") and
                        pot.IngredientsBoard.CookTimeDisplay.Face:FindFirstChild("SurfaceGui") and
                        pot.IngredientsBoard.CookTimeDisplay.Face.SurfaceGui:FindFirstChild("TimeDisplayFrame") and
                        pot.IngredientsBoard.CookTimeDisplay.Face.SurfaceGui.TimeDisplayFrame:FindFirstChild("TimeLabel")
        
        if not timerGui then
            warn("Timer GUI not found!")
            return nil
        end
        
        return timerGui.Text
    end)
    
    return success and result or nil
end

local function teleportToPotIfReady()
    local status = getCookingPotStatus()
    
    if status and (status == "Ready" or status:find("00:00")) then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then

            LocalPlayer.Character.HumanoidRootPart.CFrame = cookingPotLocation
            task.wait(1.5) 

            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - cookingPotLocation.Position).Magnitude
            if distance < 10 then
                print("✅ Successfully teleported to cooking pot!")
                return true
            else
                warn("❌ Failed to teleport! Distance:", distance)
                return false
            end
        end
    end
    return false
end

local function waitForCookingToFinish()
    local startTime = os.clock()
    local lastTime = nil
    
    while cookAutomationActive do
        local currentTimeStr = getCurrentCookingTime()
        if not currentTimeStr then
            createColoredNotification("Failed to read cooking time!", "Rarity: Common")
            return false
        end

        if (currentTimeStr == "Ready" or currentTimeStr:find("00:00")) then
            return true
        end

        if lastTime and lastTime == currentTimeStr then
            if os.clock() - startTime > 300 then 
                createColoredNotification("Cooking timer stuck! Resetting...", "Rarity: Common")
                return false
            end
        end
        
        lastTime = currentTimeStr
        task.wait(1)
    end
    
    return false
end

local function submitSoup()
    local soup
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and item.Name:find("Soup") then
            soup = item
            break
        end
    end
    
    if not soup then return false end
    
    soup.Parent = LocalPlayer.Character
    task.wait(0.5)
    
    local args = {
	"SubmitHeldFood"
}
game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SubmitFoodService_RE"):FireServer(unpack(args))

    
    if soup.Parent == LocalPlayer.Character then
        soup.Parent = LocalPlayer.Backpack
    end
    
    return true
end

local function cookEventLoop()
    setBackpackLimit()

    if countBackpackItems() == 0 then
        createColoredNotification("Backpack empty! Fill with fruits first.", "Rarity: Common")
        cookAutomationActive = false
        return
    end

    while cookAutomationActive do
        local hasSoup = false
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:find("Soup") then
                hasSoup = true
                break
            end
        end

        if hasSoup then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = npcLocation
                task.wait(1.5)
                submitSoup()
                task.wait(1)
            end
        end

        local potStatus = getCookingPotStatus()

        if potStatus and (potStatus:find("00:00") or potStatus == "Ready") then
            if teleportToPotIfReady() then
                game:GetService("ReplicatedStorage").GameEvents.CookingPotService_RE:FireServer("CollectCookedFood")
                createColoredNotification("🍜 Collected cooked soup!", "Rarity: Common")
                task.wait(1)
                local args = {"GetFoodFromPot"}
	            game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CookingPotService_RE"):FireServer(unpack(args))
            end
        else
            if countBackpackItems() < (maxBackpackItems / 2) then
                collectTargetFruits3()
            end
        end

        task.wait(1) 
    end
end

local originalCFrame = nil
local originalLocationStored = false

tab2:CreateToggle("AFK Farm Cook Event", function(state)
    if state then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            originalCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
            originalLocationStored = true
        end
        
        if countBackpackItems() == 0 then
            createColoredNotification("Fill your backpack with fruits first!", "Rarity: Common")
            return
        end

        cookAutomationActive = state

        if cookingLoopThread then
            task.cancel(cookingLoopThread)
            cookingLoopThread = nil
        end

        cookingLoopThread = task.spawn(function()
            cookEventLoop()
            cookingLoopThread = nil 
        end)
    else
        cookAutomationActive = false

        if cookingLoopThread then
            task.cancel(cookingLoopThread)
            cookingLoopThread = nil
        end

        if originalLocationStored and originalCFrame then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = originalCFrame
                task.wait(1) 
            end
            originalLocationStored = false
            originalCFrame = nil
        end

        createColoredNotification("Cook Event farming stopped", "Rarity: Common")
    end
end)

tab:Show()

library.OnDestroy = function()
    print("Destroying all created instances...")

    for _, loop in pairs(cleanup.loops) do
        if type(loop) == "thread" then
            coroutine.close(loop)
        end
    end

    for _, connection in ipairs(cleanup.connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end

    managePrompts(false)

    if cleanup.countdownGui then
        cleanup.countdownGui:Destroy()
    end

    enabled = nil
    autoBuyActive = false
    savedPrompts = {}
    playerFarm = nil

    cleanup.connections = {}
    cleanup.loops = {}

    if petCooldownConnection then
        petCooldownConnection:Disconnect()
        petCooldownConnection = nil
    end
    
    for _, data in pairs(petCooldownDisplays) do
        if data.display and data.display.Parent then
            data.display.Parent:Destroy()
        end
    end
    petCooldownDisplays = {}

    tranquilAutomationActive = false

    getgenv().script_loaded = false
    
    print("Cleanup complete!")
end
