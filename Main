if getgenv().script_loaded then return end
getgenv().script_loaded = true

local library = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Phynomie/growagarden/main/Library"))()
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

-- Load Notification module
local Notification
local success, err = pcall(function()
    Notification = require(ReplicatedStorage.Modules.Notification)
end)
if not success then
    warn("Failed to load Notification module: "..tostring(err))
    -- Fallback to default notifications
    Notification = {
        CreateNotification = function(text)
            StarterGui:SetCore("SendNotification", {
                Title = "GAG Script",
                Text = text,
                Duration = 5
            })
        end
    }
end

-- Rarity color mapping
local RARITY_COLORS = {
    Common = "#FFFFFF",       -- White
    Uncommon = "#00FF00",     -- Light Green
    Rare = "#0000FF",         -- Blue
    Legendary = "#FFFF00",    -- Light Yellow
    Mythical = "#800080",     -- Light Purple
    Divine = "#FFA500",       -- Orange
    Prismatic = "#00FFFF",    -- Aqua
    Transcendent = "#000000"  -- Black
}

local automationToggles = {
    kitsune = nil,
    tranquil = nil
}

local function getRarityColor(rarityText)
    -- Extract the actual rarity name from the text (e.g., "Rarity: Common" -> "Common")
    local rarity = rarityText:gsub("Rarity: ", ""):gsub("%s+", "")
    return RARITY_COLORS[rarity] or RARITY_COLORS.Common
end

local function createColoredNotification(text, rarityText)
    local color = getRarityColor(rarityText)
    if color == RARITY_COLORS.Common then
        -- Default color (no HTML tags)
        Notification:CreateNotification(text)
    else
        Notification:CreateNotification(string.format('<font color="%s">%s</font>', color, text))
    end
end

local cleanup = {
    connections = {},
    instances = {},
    loops = {},
    hooks = {}
}

local Main = library:CreateWindow("Grow a garden script (Creds to Phy)","Crimson")

local tab = Main:CreateTab("Exploits")
local tab2 = Main:CreateTab("Automation")
local tab3 = Main:CreateTab("Misc")

-- Farm protection system
local savedPrompts = {}
local playerFarm = nil
local enabled = nil

local function findPlayerFarm()
    local username = LocalPlayer.Name
    local farms = workspace:FindFirstChild("Farm")
    
    if not farms then
        warn("Farm system not found in workspace")
        return nil
    end

    for _, farmFolder in ipairs(farms:GetDescendants()) do
        if farmFolder.Name == "Owner" and farmFolder:IsA("StringValue") and farmFolder.Value == username then
            print("Found Your Farm! " .. username)
            return farmFolder.Parent.Parent.Parent
        end
    end
    
    warn("Could not find farm belonging to: " .. username)
    return nil
end

local function managePrompts(enable)
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return end
    end

    for _, prompt in ipairs(playerFarm:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") then
            local isEggORCratePrompt = false
            local current = prompt.Parent
            while current ~= nil and current ~= playerFarm do
                if current.Name == "PetEgg" or current.Name == "CosmeticCrate" then
                    isEggORCratePrompt = true
                    break
                end
                current = current.Parent
            end
            
            if not isEggORCratePrompt then
                if enable then
                    if not savedPrompts[prompt] then
                        savedPrompts[prompt] = {
                            Enabled = prompt.Enabled,
                            HoldDuration = prompt.HoldDuration,
                            ActionText = prompt.ActionText
                        }
                    end
                    prompt.Enabled = false
                    prompt.HoldDuration = math.huge
                    prompt.ActionText = "Disabled"
                else
                    if savedPrompts[prompt] then
                        prompt.Enabled = savedPrompts[prompt].Enabled
                        prompt.HoldDuration = savedPrompts[prompt].HoldDuration
                        prompt.ActionText = savedPrompts[prompt].ActionText
                    end
                end
            end
        end
    end
end

local function simulateClick(x, y)
    VirtualInputManager:SendMouseMoveEvent(x, y, game)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    task.wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function sendNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 5,
        Icon = "rbxassetid://6726579484"
    })
end

local function autoBuySeeds()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local seedShop = LocalPlayer.PlayerGui:FindFirstChild("Seed_Shop")
    if not seedShop then
        createColoredNotification("Seed shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = seedShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuySeedStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." seeds!", rarityText)
                end
            end
        end
    end
end

local function autoBuyGears()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local gearShop = LocalPlayer.PlayerGui:FindFirstChild("Gear_Shop")
    if not gearShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = gearShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyGearStock"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.." gears!", rarityText)
                end
            end
        end
    end
end

local function autoBuyEggs()
    local sheckles = LocalPlayer.leaderstats.Sheckles.Value
    if sheckles < 10000000000 then -- 1 billion
        createColoredNotification("You can only use this if you have more than 10B sheckles!", "Rarity: Common")
        return
    end

    local eggShop = LocalPlayer.PlayerGui:FindFirstChild("PetShop_UI")
    if not eggShop then
        createColoredNotification("Gear shop not open!", "Rarity: Common")
        return
    end

    local scrollingFrame = eggShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return end

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    for i = 1, stockNum do
                        local args = {frame.Name}
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyPetEgg"):FireServer(unpack(args))
                        task.wait(0.1)
                    end
                    createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                end
            end
        end
    end
end

local function autoBuyTM()
    -- First check if the shop is even open
    local TMShop = LocalPlayer.PlayerGui:FindFirstChild("TravelingMerchantShop_UI")
    if not TMShop then
        createColoredNotification("Traveling Merchant shop not open!", "Rarity: Common")
        return false
    end

    -- Check honey UI if it exists (for honey-based purchases)
    local honeyUI = LocalPlayer.PlayerGui:FindFirstChild("Honey_UI")
    local playerHoney = 0
    if honeyUI and honeyUI:FindFirstChild("Frame") and honeyUI.Frame:FindFirstChild("TextLabel1") then
        playerHoney = tonumber(honeyUI.Frame.TextLabel1.Text:match("%d+")) or 0
    end

    local scrollingFrame = TMShop.Frame:FindFirstChildOfClass("ScrollingFrame")
    if not scrollingFrame then return false end

    local madePurchase = false

    for _, frame in ipairs(scrollingFrame:GetChildren()) do
        if not frame.Name:find("_Padding") and frame:FindFirstChild("Main_Frame") then
            local mainFrame = frame.Main_Frame
            local stockText = mainFrame:FindFirstChild("Stock_Text")
            local priceText = mainFrame:FindFirstChild("Price_Text") -- Check for price text
            local rarityText = mainFrame:FindFirstChild("Rarity_Text") and mainFrame.Rarity_Text.Text or "Rarity: Common"
            
            if stockText and stockText.Text ~= "X0 Stock" then
                local stockNum = tonumber(stockText.Text:match("X(%d+)"))
                if stockNum and stockNum > 0 then
                    -- Check if this is a honey purchase
                    local isHoneyPurchase = false
                    local price = 0
                    
                    if priceText then
                        local priceStr = priceText.Text:lower()
                        if priceStr:find("honey") then
                            isHoneyPurchase = true
                            price = tonumber(priceStr:match("%d+")) or 0
                        end
                    end

                    if isHoneyPurchase then
                        -- Honey-based item logic
                        if playerHoney >= price then
                            for i = 1, stockNum do
                                if playerHoney >= price then -- Check honey again in case it changed
                                    local args = {frame.Name}
                                    ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                    playerHoney = playerHoney - price
                                    task.wait(0.1)
                                    madePurchase = true
                                else
                                    createColoredNotification("Ran out of honey while purchasing "..frame.Name, "Rarity: Common")
                                    break
                                end
                            end
                            if madePurchase then
                                createColoredNotification("Bought "..stockNum.." "..frame.Name.." for honey!", rarityText)
                            end
                        else
                            createColoredNotification("You need "..price.." honey to buy "..frame.Name, "Rarity: Common")
                        end
                    else
                        -- Sheckles-based item logic
                        local sheckles = LocalPlayer.leaderstats.Sheckles.Value
                        if sheckles >= 10000000000 then -- 10B sheckles check
                            for i = 1, stockNum do
                                local args = {frame.Name}
                                ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock"):FireServer(unpack(args))
                                task.wait(0.1)
                                madePurchase = true
                            end
                            createColoredNotification("Bought "..stockNum.." "..frame.Name.."!", rarityText)
                        else
                            createColoredNotification("You need 10B sheckles to buy regular TM items", "Rarity: Common")
                            break
                        end
                    end
                end
            end
        end
    end

    return madePurchase
end

tab:CreateToggle("Anti Collect Fruits", function(a)
    if a then
        managePrompts(true)
    else
        managePrompts(false)
    end
end)

local rarityMultipliers = {
    ["Gold"] = 20,   
    ["Rainbow"] = 50
}

local fruitInfoEnabled = false
local fruitInfoFrame = nil

local function createFruitInfoUI()
    -- First, ensure we have a PlayerGui to parent to
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    -- Remove any existing frame
    if fruitInfoFrame then 
        fruitInfoFrame:Destroy()
        fruitInfoFrame = nil
        task.wait(0.1) -- Small delay to ensure cleanup
    end
    
    -- Create the main frame with absolute positioning
    fruitInfoFrame = Instance.new("ScreenGui")
    fruitInfoFrame.Name = "FruitInfoGUI"
    fruitInfoFrame.ResetOnSpawn = false
    fruitInfoFrame.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    fruitInfoFrame.DisplayOrder = 10 -- High priority display
    fruitInfoFrame.Parent = playerGui
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 300, 0, 200) -- Fixed size
    mainFrame.Position = UDim2.new(0.006, 0, 0.57, 0) -- Top-left corner
    mainFrame.AnchorPoint = Vector2.new(0, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    mainFrame.BackgroundTransparency = 0.15
    mainFrame.BorderSizePixel = 0
    mainFrame.Visible = fruitInfoEnabled -- Start visible if enabled
    mainFrame.Parent = fruitInfoFrame
    
    -- Add visual elements
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainFrame
    
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = Color3.fromRGB(100, 100, 255)
    uiStroke.Thickness = 2
    uiStroke.Parent = mainFrame
    
    -- Title bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BackgroundTransparency = 0.3
    titleBar.Parent = mainFrame
    
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -10, 1, 0)
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "FRUIT INFORMATION"
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 16
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar
    
    -- Content area
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Size = UDim2.new(1, -10, 1, -40)
    contentFrame.Position = UDim2.new(0, 5, 0, 35)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame
    
    -- Fruit name display with ScrollingFrame
    local nameFrame = Instance.new("Frame")
    nameFrame.Name = "NameFrame"
    nameFrame.Size = UDim2.new(1, 0, 0, 30)
    nameFrame.Position = UDim2.new(0, 0, 0, 0)
    nameFrame.BackgroundTransparency = 1
    nameFrame.Parent = contentFrame
    
    local nameScrollingFrame = Instance.new("ScrollingFrame")
    nameScrollingFrame.Name = "NameScroller"
    nameScrollingFrame.Size = UDim2.new(1, 0, 1, 0)
    nameScrollingFrame.Position = UDim2.new(0, 0, 0, 0)
    nameScrollingFrame.BackgroundTransparency = 1
    nameScrollingFrame.ScrollBarThickness = 4
    nameScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 255)
    nameScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.X -- Auto-expand horizontally
    nameScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    nameScrollingFrame.Parent = nameFrame
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(0, 0, 1, 0) -- Width will auto-size
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = "No fruit equipped"
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.Font = Enum.Font.GothamSemibold
    nameLabel.TextSize = 18
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.TextWrapped = false -- Important for horizontal scrolling
    nameLabel.AutomaticSize = Enum.AutomaticSize.X -- Auto-size width to text
    nameLabel.Parent = nameScrollingFrame
    
    -- Mutations display with scrolling
    local mutationsFrame = Instance.new("ScrollingFrame")
    mutationsFrame.Name = "MutationsFrame"
    mutationsFrame.Size = UDim2.new(1, 0, 0, 100)
    mutationsFrame.Position = UDim2.new(0, 0, 0, 35)
    mutationsFrame.BackgroundTransparency = 1
    mutationsFrame.ScrollBarThickness = 4
    mutationsFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 255)
    mutationsFrame.Parent = contentFrame
    
    local mutationsLayout = Instance.new("UIListLayout")
    mutationsLayout.Padding = UDim.new(0, 5)
    mutationsLayout.Parent = mutationsFrame
    
    -- Price display
    local priceFrame = Instance.new("Frame")
    priceFrame.Name = "PriceFrame"
    priceFrame.Size = UDim2.new(1, 0, 0, 30)
    priceFrame.Position = UDim2.new(0, 0, -0.01, 135)
    priceFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 40)
    priceFrame.BackgroundTransparency = 0.5
    priceFrame.Parent = contentFrame
    
    local priceLabel = Instance.new("TextLabel")
    priceLabel.Name = "PriceLabel"
    priceLabel.Size = UDim2.new(1, -10, 1, 0)
    priceLabel.Position = UDim2.new(0, 10, 0, 0)
    priceLabel.BackgroundTransparency = 1
    priceLabel.Text = "Value: $0"
    priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    priceLabel.Font = Enum.Font.GothamBold
    priceLabel.TextSize = 16
    priceLabel.TextXAlignment = Enum.TextXAlignment.Left
    priceLabel.Parent = priceFrame

    local cornerUI = Instance.new("UICorner")
    cornerUI.CornerRadius = UDim.new(0.5, 8)
    cornerUI.Parent = priceFrame
    
    -- Ensure the frame is properly layered
    mainFrame.ZIndex = 10
    titleBar.ZIndex = 11
    titleText.ZIndex = 12
    contentFrame.ZIndex = 11
    nameFrame.ZIndex = 12
    nameScrollingFrame.ZIndex = 13
    nameLabel.ZIndex = 14
    mutationsFrame.ZIndex = 12
    priceFrame.ZIndex = 12
    priceLabel.ZIndex = 13
    
    return fruitInfoFrame
end

local Item_Module = require(ReplicatedStorage.Item_Module)
local MutationHandler = require(ReplicatedStorage.Modules.MutationHandler)
local InventoryServiceEnums = require(ReplicatedStorage.Data.EnumRegistry.InventoryServiceEnums)

local function CalculatePlantValue(plant)
    local Item_String = plant:FindFirstChild("Item_String")
    local itemName
    if Item_String and Item_String.Value ~= "" then
        itemName = Item_String.Value
    else
        itemName = plant.Name
    end

    local Variant = plant:FindFirstChild("Variant")
    if not Variant then
        return 0
    end

    local Weight = plant:FindFirstChild("Weight")
    if not Weight then
        return 0
    end

    local itemData = Item_Module.Return_Data(itemName)
    if not itemData or #itemData < 3 then
        warn("CalculatePlantValue | ItemData is invalid")
        return 0
    end

    local clamped = math.clamp(Weight.Value / itemData[2], 0.95, 100000000)
    local value = (itemData[3] * MutationHandler:CalcValueMulti(plant) * Item_Module.Return_Multiplier(Variant.Value)) * (clamped * clamped)
    
    if 1 <= (plant:GetAttribute(InventoryServiceEnums.FruitVersion) or 0) then
        value = math.min(value, 1000000000000)
    end
    
    return math.round(value)
end

local lastEquippedFruit = nil
local lastUpdateTime = 0
local UPDATE_COOLDOWN = 0.5 -- Update at most every 0.5 seconds
local lastKnownAttributes = nil
local lastKnownWeight = nil

local function updateFruitInfo()
    if not fruitInfoEnabled or not fruitInfoFrame then return end
    
    local currentTime = os.clock()
    if currentTime - lastUpdateTime < UPDATE_COOLDOWN then return end
    lastUpdateTime = currentTime

    local mainFrame = fruitInfoFrame:FindFirstChild("MainFrame")
    if not mainFrame then return end

    local character = game.Players.LocalPlayer.Character
    if not character then
        return
    end

    -- Find currently equipped fruit
    local equippedFruit = nil
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") then
            equippedFruit = item
            break
        end
    end

    -- Skip update if same fruit is still equipped AND no attributes have changed
    if equippedFruit and lastEquippedFruit and equippedFruit == lastEquippedFruit then
        -- Check if any attributes have changed
        local attributesChanged = false
        local currentAttributes = {}
        
        -- Get current attributes
        for attrName, attrValue in pairs(equippedFruit:GetAttributes()) do
            if attrName ~= "d" and attrValue == true and attrName ~= "Weight" then
                table.insert(currentAttributes, attrName)
            end
        end
        
        -- Compare with last known attributes
        if #currentAttributes ~= #lastKnownAttributes then
            attributesChanged = true
        else
            for _, attr in ipairs(currentAttributes) do
                if not table.find(lastKnownAttributes, attr) then
                    attributesChanged = true
                    break
                end
            end
        end
        
        -- Also check if weight changed
        if equippedFruit:FindFirstChild("Weight") then
            if not lastKnownWeight or equippedFruit.Weight.Value ~= lastKnownWeight then
                attributesChanged = true
            end
        end
        
        if not attributesChanged then
            return -- No changes, skip update
        end
    end

    -- Reset display if no fruit equipped
    if not equippedFruit then
        local nameLabel = mainFrame.ContentFrame.NameFrame.NameScroller.NameLabel
        nameLabel.Text = "No fruit equipped"

        local mutationsFrame = mainFrame.ContentFrame.MutationsFrame
        mutationsFrame:ClearAllChildren()
        local noMutations = Instance.new("TextLabel")
        noMutations.Size = UDim2.new(1, 0, 0, 20)
        noMutations.BackgroundTransparency = 1
        noMutations.Text = "No mutations"
        noMutations.TextColor3 = Color3.fromRGB(150, 150, 150)
        noMutations.Font = Enum.Font.Gotham
        noMutations.TextSize = 14
        noMutations.TextXAlignment = Enum.TextXAlignment.Left
        noMutations.ZIndex = 13
        noMutations.Parent = mutationsFrame
        mutationsFrame.CanvasSize = UDim2.new(0, 0, 0, noMutations.AbsoluteSize.Y)

        local priceLabel = mainFrame.ContentFrame.PriceFrame.PriceLabel
        priceLabel.Text = "Value: $0 , Weight: N/A"
        priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        
        lastEquippedFruit = nil
        lastKnownAttributes = nil
        lastKnownWeight = nil
        return
    end

    -- Update last equipped fruit and store its attributes
    lastEquippedFruit = equippedFruit
    lastKnownAttributes = {}
    for attrName, attrValue in pairs(equippedFruit:GetAttributes()) do
        if attrName ~= "d" and attrValue == true and attrName ~= "Weight" then
            table.insert(lastKnownAttributes, attrName)
        end
    end
    
    -- Store weight
    if equippedFruit:FindFirstChild("Weight") then
        lastKnownWeight = equippedFruit.Weight.Value
    else
        lastKnownWeight = nil
    end

    -- Update name
    local nameLabel = mainFrame.ContentFrame.NameFrame.NameScroller.NameLabel
    nameLabel.Text = equippedFruit.Name

    -- Update mutations
    local mutationsFrame = mainFrame.ContentFrame.MutationsFrame
    mutationsFrame:ClearAllChildren()

    local mutationsLayout = Instance.new("UIListLayout")
    mutationsLayout.Padding = UDim.new(0, 5)
    mutationsLayout.Parent = mutationsFrame

    if #lastKnownAttributes > 0 then
        for _, mutation in ipairs(lastKnownAttributes) do
            local mutationLabel = Instance.new("TextLabel")
            mutationLabel.Size = UDim2.new(1, 0, 0, 20)
            mutationLabel.BackgroundTransparency = 1
            mutationLabel.Text = "• "..mutation:gsub("^%l", string.upper)
            mutationLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
            mutationLabel.Font = Enum.Font.Gotham
            mutationLabel.TextSize = 14
            mutationLabel.TextXAlignment = Enum.TextXAlignment.Left
            mutationLabel.ZIndex = 13
            mutationLabel.Parent = mutationsFrame
        end
    else
        local noMutations = Instance.new("TextLabel")
        noMutations.Size = UDim2.new(1, 0, 0, 20)
        noMutations.BackgroundTransparency = 1
        noMutations.Text = "No mutations"
        noMutations.TextColor3 = Color3.fromRGB(150, 150, 150)
        noMutations.Font = Enum.Font.Gotham
        noMutations.TextSize = 14
        noMutations.TextXAlignment = Enum.TextXAlignment.Left
        noMutations.ZIndex = 13
        noMutations.Parent = mutationsFrame
    end

    mutationsFrame.CanvasSize = UDim2.new(0, 0, 0, mutationsFrame.UIListLayout.AbsoluteContentSize.Y)

    -- Update price and weight
    local price = CalculatePlantValue(equippedFruit)
    local weight = lastKnownWeight or "???"
    local priceLabel = mainFrame.ContentFrame.PriceFrame.PriceLabel

    local priceString
    if price >= 1e12 then
        priceString = string.format("Value: $%.2fT", price/1e12)
        priceLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
    elseif price >= 1e9 then
        priceString = string.format("Value: $%.2fB", price/1e9)
        priceLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
    elseif price >= 1e6 then
        priceString = string.format("Value: $%.2fM", price/1e6)
        priceLabel.TextColor3 = Color3.fromRGB(144, 238, 144)
    else
        priceString = string.format("Value: $%.0f", price)
        priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    end

    priceLabel.Text = priceString .. string.format(" , Weight: %s", tostring(weight))
end

-- Add this connection to detect tool changes
cleanup.connections["characterAdded"] = game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if fruitInfoEnabled then
        -- Recreate UI when character respawns
        if fruitInfoFrame then
            fruitInfoFrame:Destroy()
            fruitInfoFrame = nil
        end
        fruitInfoFrame = createFruitInfoUI()
        updateFruitInfo()
    end
    cleanup.connections["childAdded"] = character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and fruitInfoEnabled then
            -- Force update when a new tool is equipped
            lastEquippedFruit = nil
            updateFruitInfo()
        end
    end)
end)

-- Create the toggle button with proper initialization
tab:CreateToggle("Show Fruit Info", function(state)
    fruitInfoEnabled = state
    
    if state then
        -- Create UI if it doesn't exist
        if not fruitInfoFrame or not fruitInfoFrame.Parent then
            fruitInfoFrame = createFruitInfoUI()
        end
        
        -- Immediately show the frame
        if fruitInfoFrame and fruitInfoFrame:FindFirstChild("MainFrame") then
            fruitInfoFrame.MainFrame.Visible = true
        end
        
        -- Start update loop
        task.spawn(function()
            while fruitInfoEnabled do
                updateFruitInfo()
                task.wait(0.5)
            end
        end)
    elseif fruitInfoFrame and fruitInfoFrame:FindFirstChild("MainFrame") then
        fruitInfoFrame.MainFrame.Visible = false
    end
end)

local function CalculateMaxMutationValue(plantName, currentWeightValue)
    local itemData = Item_Module.Return_Data(plantName)
    if not itemData or #itemData < 3 then
        warn("CalculateMaxMutationValue | ItemData is invalid for " .. plantName)
        return 0
    end

    local baseValue = itemData[3]
    local baseWeightCap = itemData[2]

    -- These are the consolidated values derived from our previous calculations
    -- Sum of all mutation multipliers from your list (excluding Rainbow/Gold as separate entries)
    local sumOfAllIndividualMutationMultipliers = 1939
    -- Total count of those individual mutations
    local numberOfIndividualMutations = 39
    -- The multiplier for Rainbow rarity (used for max value)
    local rainbowRarityMultiplier = 50

    -- This calculates the combined effect of all mutations and Rainbow rarity
    local combinedMutationFactor = rainbowRarityMultiplier * (1 + sumOfAllIndividualMutationMultipliers - numberOfIndividualMutations)

    local clampedWeight = math.clamp(currentWeightValue / baseWeightCap, 0.95, 100000000)
    local weightSquaredFactor = clampedWeight * clampedWeight

    local finalMaxCalculatedValue = baseValue * weightSquaredFactor * combinedMutationFactor

    -- IMPORTANT: Removed the 1 Trillion cap here, as your "correct number" was higher than 1T.
    -- If your game strictly caps ALL values at 1T, you can re-add this line:
    -- finalMaxCalculatedValue = math.min(finalMaxCalculatedValue, 1000000000000)

    return math.round(finalMaxCalculatedValue)
end

tab:CreateToggle("Weight Calculator", function(enabled)
    if enabled then
        print("[Weight Calculator] Enabling...")

        -- Create the tool
        local weightTool = Instance.new("Tool")
        weightTool.Name = "Weight Calculator"
        weightTool.RequiresHandle = false
        weightTool.CanBeDropped = false

        local toolTip = Instance.new("StringValue")
        toolTip.Name = "ToolTip"
        toolTip.Value = "Touch/Click fruits to check weight"
        toolTip.Parent = weightTool

        weightTool.Parent = LocalPlayer.Backpack
        print("[Weight Calculator] Tool created in backpack")

        -- Main function to check weight
        local function checkWeight(target)
            print("[Weight Calculator] Checking weight for:", target:GetFullName())

            local plant = target:FindFirstAncestorWhichIsA("Model")
            while plant do
                if plant:HasTag("Harvestable") then
                    break
                end
                plant = plant:FindFirstAncestorWhichIsA("Model")
            end

            if plant then
                print("[Weight Calculator] Found harvestable plant:", plant:GetFullName())

                local weight = plant:FindFirstChild("Weight") or
                               (plant:FindFirstChild("Fruits") and plant.Fruits:FindFirstChildWhichIsA("BasePart"):FindFirstChild("Weight"))

                if weight and weight:IsA("NumberValue") then
                    local weightKg = weight.Value
                    print("[Weight Calculator] Found weight:", weightKg)

                    local name = plant.Name -- Name of the fruit
                    local actualRarity = plant:FindFirstChild("Rarity") and plant.Rarity.Value or "Common"

                    print("name of da fruit:", name)
                    print("Actual Rarity of plant:", actualRarity) -- Show the plant's true rarity

                    -- *** CALL THE NEW MAX MUTATION CALCULATION FUNCTION HERE ***
                    local totalValueMaxMutation = CalculateMaxMutationValue(name, weightKg)
                    print("Estimated Value (Max Mutation, raw):", totalValueMaxMutation)


                    -- Format function (remains the same)
                    local function formatBillions(num)
                        if num >= 1e12 then
                            return string.format("$%.0f (%.3f Trillion)", num, num / 1e12)
                        elseif num >= 1e9 then
                            return string.format("$%.0f (%.3f Billion)", num, num / 1e9)
                        elseif num >= 1e6 then
                            return string.format("$%.0f (%.3f Million)", num, num / 1e6)
                        else
                            return string.format("$%.0f", num)
                        end
                    end

                    local formattedValue = formatBillions(totalValueMaxMutation)

                    -- The notification will now reflect the calculated value assuming Rainbow mutation
                    createColoredNotification(string.format("%s\nWeight: %.3f kg\nEstimated Value (Max Mutation): %s", name, weightKg, formattedValue), "Rarity: " .. actualRarity)

                    -- Highlight (remains the same)
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "WeightHighlight"
                    highlight.FillColor = Color3.new(1, 0.5, 0)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0
                    highlight.Adornee = plant
                    highlight.Parent = workspace

                    task.delay(2, function()
                        highlight:Destroy()
                    end)
                else
                    print("[Weight Calculator] No weight value found on plant")
                end
            else
                print("[Weight Calculator] No harvestable plant found in ancestry")
            end
        end
        -- Mobile touch detection
        if UserInputService.TouchEnabled then
            print("[Weight Calculator] Mobile device detected - setting up touch input")

            local touchConnection
            touchConnection = UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
                if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                    print("[Weight Calculator] Tool not equipped - ignoring touch")
                    return
                end

                print(string.format("[Weight Calculator] Touch detected at (%d, %d)", touch.Position.X, touch.Position.Y))

                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(touch.Position.X, touch.Position.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Touch hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Touch didn't hit anything")
                end
            end)
            cleanup.connections["WeightTouch"] = touchConnection
        else
            print("[Weight Calculator] PC detected - setting up mouse input")
        end

        -- PC click detection
        local clickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator")) then
                print("[Weight Calculator] Tool not equipped - ignoring click")
                return
            end

            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                print("[Weight Calculator] Mouse click detected")

                local mousePos = UserInputService:GetMouseLocation()
                local camera = workspace.CurrentCamera
                local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {workspace.Farm}
                raycastParams.FilterType = Enum.RaycastFilterType.Include

                local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
                if raycastResult and raycastResult.Instance then
                    print("[Weight Calculator] Click hit:", raycastResult.Instance:GetFullName())
                    checkWeight(raycastResult.Instance)
                else
                    print("[Weight Calculator] Click didn't hit anything")
                end
            end
        end)
        cleanup.connections["WeightClick"] = clickConnection

        -- Tool equipped handling
        local function onEquipped()
            print("[Weight Calculator] Tool equipped")
            createColoredNotification("Weight Calculator ready\nTouch/Click fruits to check weight", "Rarity: Common")
        end

        cleanup.connections["weightToolEquipped"] = weightTool.Equipped:Connect(onEquipped)
        cleanup.connections["weightToolUnequipped"] = weightTool.Unequipped:Connect(function()
            print("[Weight Calculator] Tool unequipped")
        end)

        createColoredNotification("Weight Calculator enabled\nEquip the tool from your backpack", "Rarity: Common")
    else
        print("[Weight Calculator] Disabling...")

        -- Cleanup connections
        for name, conn in pairs(cleanup.connections) do
            if name:find("Weight") then
                conn:Disconnect()
                cleanup.connections[name] = nil
                print("[Weight Calculator] Disconnected:", name)
            end
        end

        -- Remove tool
        if LocalPlayer.Backpack:FindFirstChild("Weight Calculator") then
            LocalPlayer.Backpack["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed tool from backpack")
        end

        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Weight Calculator") then
            LocalPlayer.Character["Weight Calculator"]:Destroy()
            print("[Weight Calculator] Removed equipped tool")
        end

        createColoredNotification("Weight Calculator disabled", "Rarity: Common")
    end
end)

local petCooldownEnabled = false
local petCooldownDisplays = {}
local petCooldownConnection = nil
local lastUpdateTime = 0
local UPDATE_INTERVAL = 2 -- Reduced update interval for better responsiveness

local function createPetDisplay(pet)
    local head = pet:FindFirstChild("Head") or pet:FindFirstChildWhichIsA("BasePart")
    if not head then return nil end
    
    -- Remove any existing display
    if head:FindFirstChild("PetCooldownDisplay") then
        head.PetCooldownDisplay:Destroy()
    end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PetCooldownDisplay"
    billboard.Size = UDim2.new(10, 0, 4, 0)
    billboard.StudsOffset = Vector3.new(0, 3, 0) -- Adjusted height
    billboard.AlwaysOnTop = true
    billboard.Adornee = head
    billboard.LightInfluence = 0
    billboard.MaxDistance = 150 -- Increased view distance
    billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    billboard.Parent = head

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = billboard

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "Loading..."
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 16
    textLabel.TextStrokeTransparency = 0.3
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.TextWrapped = true
    textLabel.Parent = frame

    -- Make larger on mobile
    if UserInputService.TouchEnabled then
        billboard.Size = UDim2.new(15, 0, 6, 0)
        billboard.StudsOffset = Vector3.new(0, 2.5, 0)
        textLabel.TextSize = 20
    end

    return textLabel
end

local function updatePetDisplay(petName, display)
    local success, cooldownData = pcall(function()
        return game:GetService("ReplicatedStorage").GameEvents.GetPetCooldown:InvokeServer(petName)
    end)

    if success and type(cooldownData) == "table" then
        local activeAbilities = {}
        
        for _, entry in ipairs(cooldownData) do
            if type(entry) == "table" and entry.Passive then
                local timeLeft = entry.Time or 0
                local totalTime = entry.Cooldown or entry.MaxTime or 60
                local percentage = math.clamp(timeLeft / totalTime, 0, 1)
                
                local status = timeLeft > 0 and string.format("%s: %ds (%.0f%%)", 
                    entry.Passive, timeLeft, percentage * 100)
                    or string.format("%s: Ready!", entry.Passive)
                
                local color = timeLeft > 0 and Color3.fromHSV(percentage * 0.3, 1, 1) -- Red to yellow gradient
                    or Color3.new(0.5, 1, 0.5) -- Green when ready
                
                table.insert(activeAbilities, {
                    text = status,
                    color = color
                })
            end
        end

        if #activeAbilities > 0 then
            local displayText = ""
            for i, ability in ipairs(activeAbilities) do
                displayText = displayText .. ability.text
                if i < #activeAbilities then
                    displayText = displayText .. "\n"
                end
            end
            display.Text = displayText
            
            -- Use first ability's color if only one, otherwise white
            display.TextColor3 = #activeAbilities == 1 and activeAbilities[1].color or Color3.new(1, 1, 1)
        else
            display.Text = "No active abilities"
            display.TextColor3 = Color3.new(0.8, 0.8, 0.8)
        end
    else
        display.Text = "Error fetching data"
        display.TextColor3 = Color3.new(1, 0, 0)
    end
end

local function scanAndUpdatePets()
    if not petCooldownEnabled then return end
    
    local currentTime = os.clock()
    if currentTime - lastUpdateTime < UPDATE_INTERVAL then return end
    lastUpdateTime = currentTime

    -- Find all pets in workspace (including other players' pets)
    local currentPets = {}
    for _, pet in ipairs(workspace:GetDescendants()) do
        -- Look for pet models (they typically have curly braces in their name)
        if pet:IsA("Model") and pet.Name:match("^{.+}$") then
            -- Additional check to confirm it's a pet (has Humanoid or PetMover)
            if pet:FindFirstChild("Humanoid") or pet:FindFirstChildWhichIsA("BasePart") then
                currentPets[pet.Name] = pet
            end
        end
    end
    
    -- Clean up displays for pets that no longer exist
    for petName, data in pairs(petCooldownDisplays) do
        if not currentPets[petName] then
            if data.display and data.display.Parent then
                data.display.Parent:Destroy()
            end
            petCooldownDisplays[petName] = nil
        end
    end
    
    -- Update all active displays
    for petName, pet in pairs(currentPets) do
        if not petCooldownDisplays[petName] then
            local display = createPetDisplay(pet)
            if display then
                petCooldownDisplays[petName] = {
                    display = display,
                    pet = pet,
                    lastUpdate = 0
                }
            end
        end
        
        if petCooldownDisplays[petName] then
            updatePetDisplay(petName, petCooldownDisplays[petName].display)
            petCooldownDisplays[petName].lastUpdate = currentTime
        end
    end
end

tab:CreateToggle("Show All Pet Cooldowns", function(enabled)
    petCooldownEnabled = enabled
    
    if enabled then
        -- Initial scan
        scanAndUpdatePets()
        
        -- Set up recurring updates
        petCooldownConnection = game:GetService("RunService").Heartbeat:Connect(function()
            scanAndUpdatePets()
        end)
        
        createColoredNotification("Pet cooldowns enabled - Showing all pets", "Rarity: Common")
    else
        -- Clean up
        if petCooldownConnection then
            petCooldownConnection:Disconnect()
            petCooldownConnection = nil
        end
        
        for _, data in pairs(petCooldownDisplays) do
            if data.display and data.display.Parent then
                data.display.Parent:Destroy()
            end
        end
        petCooldownDisplays = {}
        
        createColoredNotification("Pet cooldowns disabled", "Rarity: Common")
    end
end)

tab:CreateToggle("Anti-Kick", function(enabled)
    local namecallHook
    
    if enabled then
        -- Create the hook when toggle is enabled
        namecallHook = hookmetamethod(game.Players.LocalPlayer, "__namecall", function(...)
            local method = getnamecallmethod()
            if method == "Kick" then
                print("[Anti-Kick] Blocked kick attempt")
                return nil
            end
            return namecallHook(...)
        end)

        -- Verify the hook was successful
        if typeof(namecallHook) == "function" then
            print("[Anti-Kick] Protection enabled successfully")
        else
            warn("[Anti-Kick] Failed to create protection!")
            return
        end

        -- Store the hook in cleanup table
        cleanup.connections["AntiKick"] = namecallHook
    else
        -- Disable the hook when toggle is turned off
        if cleanup.connections["AntiKick"] then
            if unhookmetamethod then
                unhookmetamethod(game.Players.LocalPlayer, "__namecall", cleanup.connections["AntiKick"])
            end
            cleanup.connections["AntiKick"] = nil
            print("[Anti-Kick] Protection disabled")
        end
    end
end)

tab:CreateToggle("Anti-Afk", function(enabled)
    if enabled then
        sendNotification("✅ Anti-AFK", "Anti AFK has been enabled.", 5)
        
        -- Disable all existing Idled connections
        cleanup.connections["antiAfk"] = {}

        -- Disable all idle connections and store original states
        for _, connection in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
            local originalState = connection.Enabled
            connection:Disable()
    
            -- Store in cleanup table with restore information
            table.insert(cleanup.connections["antiAfk"], {
                connection = connection,
                originalState = originalState
            })
        end
        
    else
        sendNotification("❌ Anti-AFK", "Anti AFK has been disabled.", 5)
        
        if cleanup.connections["antiAfk"] then
            for _, afkData in ipairs(cleanup.connections["antiAfk"]) do
                if afkData.connection and typeof(afkData.connection) == "userdata" then
                    -- Restore original enabled state
                    afkData.connection.Enabled = afkData.originalEnabled
                end
            end
            cleanup.connections["antiAfk"] = nil  -- Clear the stored connections
        end
    
    end
end)

tab:CreateButton("Sell Equipped Fruit/Pet", function()
    local function isPet(tool)
        return tool:FindFirstChild("Age") or tool:FindFirstChild("KG")
    end

    -- Check equipped items first
    local equippedPet = nil
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                equippedPet = item
                break
            end
        end
    end

    -- If no pet equipped, check backpack
    if not equippedPet then
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") and isPet(item) then
                equippedPet = item
                break
            end
        end
    end

    -- If we found a pet (equipped or in backpack), sell it
    if equippedPet then
        createColoredNotification("Found pet ("..equippedPet.Name..") - selling...", "Rarity: Common")
        
        -- Equip the pet if it's not already equipped
        if equippedPet.Parent ~= LocalPlayer.Character then
            equippedPet.Parent = LocalPlayer.Character
            task.wait(0.5) -- Wait for equip animation
        end

        -- Sell the pet
        local args = { equippedPet }
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SellPet_RE"):FireServer(unpack(args))
        task.wait(0.5) -- Wait for pet to be sold
        
        -- Verify pet was sold
        if equippedPet and equippedPet.Parent then
            createColoredNotification("Failed to sell pet!", "Rarity: Common")
            return
        end
    end

    -- Now proceed with fruit selling if we have an equipped fruit
    local equippedFruit = nil
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and not isPet(item) then
                equippedFruit = item
                break
            end
        end
    end

    if equippedFruit then
        local steven = workspace.NPCS:FindFirstChild("Steven")
        if not steven then
            warn("Steven NPC not found!")
            return
        end
        
        local npcHRP = steven:FindFirstChild("HumanoidRootPart")
        if not npcHRP then
            warn("Steven doesn't have HumanoidRootPart!")
            return
        end
        
        local playerChar = LocalPlayer.Character
        if not playerChar then
            warn("Player character not found!")
            return
        end
        
        local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
        if not playerHRP then
            warn("Player doesn't have HumanoidRootPart!")
            return
        end
        
        local originalCFrame = playerHRP.CFrame
        
        playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
        
        task.wait(0.2)
        
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Item"):FireServer()
        
        task.wait(0.2)
        
        playerHRP.CFrame = originalCFrame
        createColoredNotification("Sold equipped fruit: "..equippedFruit.Name, "Rarity: Common")
    elseif not equippedPet then
        createColoredNotification("No equipped pet or fruit found!", "Rarity: Common")
    end
end)

tab:CreateButton("Sell All Fruits", function()
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return
    end
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return
    end
    
    local originalCFrame = playerHRP.CFrame
    
    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    
    task.wait(0.2)
    
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Inventory"):FireServer()
    
    task.wait(0.2)
    
    playerHRP.CFrame = originalCFrame
end)

local autoBuyActive = false
cleanup.loops.buyLoop = nil

local countdownGui = Instance.new("ScreenGui")
countdownGui.Name = "AutoBuyCountdown"
countdownGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 50)
frame.Position = UDim2.new(0.085, 0, 0.4, 0)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
frame.BackgroundTransparency = 0.5
frame.BorderSizePixel = 0
frame.Visible = false
frame.Parent = countdownGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0.4, 0)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Next Auto-Buy In:"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.Gotham
title.TextSize = 14
title.Parent = frame

local timerText = Instance.new("TextLabel")
timerText.Size = UDim2.new(1, 0, 0.6, 0)
timerText.Position = UDim2.new(0, 0, 0.4, 0)
timerText.BackgroundTransparency = 1
timerText.Text = "60s"
timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
timerText.Font = Enum.Font.GothamBold
timerText.TextSize = 18
timerText.Parent = frame

local progressBar = Instance.new("Frame")
progressBar.Size = UDim2.new(1, 0, 0, 3)
progressBar.Position = UDim2.new(0, 0, 1, -3)
progressBar.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
progressBar.BorderSizePixel = 0
progressBar.Parent = frame

local progressFill = Instance.new("Frame")
progressFill.Size = UDim2.new(1, 0, 1, 0)
progressFill.Position = UDim2.new(0, 0, 0, 0)
progressFill.BackgroundColor3 = Color3.fromRGB(220, 20, 60) -- Crimson
progressFill.BorderSizePixel = 0
progressFill.Parent = progressBar

local function stopBuyLoop()
    if cleanup.loops.buyLoop then
        cleanup.loops.buyLoop = nil
    end
    autoBuyActive = false
    frame.Visible = false
end

local function startBuyLoop()
    cleanup.loops.buyLoop = coroutine.create(function()
        while autoBuyActive do
            frame.Visible = true
            
            autoBuySeeds()
            autoBuyGears()
            autoBuyEggs()
            autoBuyTM()
            
            for i = 60, 1, -1 do
                if not autoBuyActive then break end
                
                timerText.Text = i.."s"
                progressFill.Size = UDim2.new(i/60, 0, 1, 0)
                
                local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(progressFill, tweenInfo, {Size = UDim2.new((i-1)/60, 0, 1, 0)})
                tween:Play()
                
                task.wait(1)
            end
        end
        stopBuyLoop()
    end)
    coroutine.resume(cleanup.loops.buyLoop)
end

tab2:CreateToggle("Auto Buy Seed/Gear/Egg/TM", function(a)
    autoBuyActive = a
    
    if a then
        if not cleanup.loops.buyLoop then
            startBuyLoop()
        end
    else
        stopBuyLoop()
    end
end)

local fruits = {}
local playerPosition = nil
local isRunning = false -- This flag can be used to prevent both automations from running simultaneously
local savedTool = nil

-- Global helper functions (defined once at the top)
local function getFruits()
    fruits = {}
    print("getFruits() called: Scanning backpack and character for fruits.")
    -- Check both backpack and equipped fruits
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
            table.insert(fruits, item)
            print("Found fruit in backpack: " .. item.Name)
        end
    end
    -- Check equipped tool
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                table.insert(fruits, item)
                print("Found fruit equipped: " .. item.Name)
            end
        end
    end
    print("Total fruits found: " .. #fruits)
end

-- This submitFruit is specifically for Kitsune's "SubmitToFox" logic
local function submitFruit(fruit)
    print("Attempting to submit fruit to Kitsune: " .. fruit.Name)
    -- Equip the fruit first
    fruit.Parent = LocalPlayer.Character
    task.wait(0.2) -- Give time to equip
    print("Fruit equipped: " .. fruit.Name)

    -- Submit to Kitsune
    local args = {"SubmitToFox"}
    game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))
    print("Fired RemoteEvent: ZenQuestRemoteEvent with args 'SubmitToFox'")

    -- Small delay before next action
    task.wait(0.5)
    print("Kitsune submit fruit delay complete.")
end

-- shouldSkipItem function, which includes the skipPatterns table
local function shouldSkipItem(itemName)
    local lowerName = itemName:lower()

    -- Skip list (case-insensitive) - THIS IS THE IMPORTANT PART
    local skipPatterns = {
        "staff",           -- Catches all staff variants
        "crate",           -- Catches all crates
        "radar",
        "spray x%d+ %[",    -- Mutation sprays (x1/x2 with brackets)
        "corrupted zen",   -- Specific crate type
        "corrupted kodama", -- Catches "Shiny Corrupted Kodama" and similar
        "corrupted kitsune",
        "seed"
    }

    for _, pattern in ipairs(skipPatterns) do
        if lowerName:find(pattern) then
            -- print("DEBUG: '" .. itemName .. "' matches skip pattern '" .. pattern .. "'")
            return true
        end
    end
    return false
end

local function createAutomationToggles()
    -- Kitsune Toggle
    automationToggles.kitsune = function(state)
        if state then
            print("Toggle ON: Starting Kitsune automation.")
            -- Prevent simultaneous execution if another automation is running
            if isRunning then
                createColoredNotification("🚫 Another automation is already running. Please turn it off first.", "Rarity: Common")
                return
            end

            -- Store currently equipped tool (if not a fruit)
            if LocalPlayer.Character then
                for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                    if item:IsA("Tool") and not (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                        savedTool = item
                        item.Parent = LocalPlayer.Backpack
                        print("Saved equipped tool: " .. item.Name)
                        break
                    end
                end
            end

            isRunning = true -- Set flag to true as this automation starts
            createColoredNotification("✅ Starting Kitsune fruit submission...", "Rarity: Common")
            createColoredNotification("This Automation will skip favorited fruits", "Rarity: Common")

            -- Store original position
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                playerPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                print("Player position saved.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found. Cannot save position!", "Rarity: Common")
                isRunning = false
                return
            end

            -- Teleport to Kitsune
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-101.82, 3.0, -13.08)
                print("Teleporting to Kitsune.")
                task.wait(1) -- Wait for teleport
                print("Teleport wait complete.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found for teleport! Stopping.", "Rarity: Common")
                isRunning = false
                return
            end

            -- Get current levels (initial read)
            local TranquilLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
            local CorruptLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)

            print(string.format("Initial Levels: Tranquil=%s, Corrupt=%s", tostring(TranquilLevel), tostring(CorruptLevel)))

            local validTranquilLevel = type(TranquilLevel) == "number" and TranquilLevel >= 0 and TranquilLevel <= 5
            local validCorruptLevel = type(CorruptLevel) == "number" and CorruptLevel >= 0 and CorruptLevel <= 5

            if not (validTranquilLevel and validCorruptLevel) then
                createColoredNotification("❌ Invalid level values detected! Cannot proceed.", "Rarity: Common")
                print("ERROR: Invalid initial levels. Stopping automation.")
                isRunning = false
                -- Return to original position before stopping due to error
                if playerPosition then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                end
                if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                    task.wait(0.5)
                    savedTool.Parent = LocalPlayer.Character
                    savedTool = nil
                end
                return
            end

            -- Process fruits
            getFruits() -- Initial population of fruits table
            if #fruits == 0 then
                createColoredNotification("No fruits found to submit for Kitsune.", "Rarity: Common")
                print("No fruits found initially for Kitsune. Stopping automation.")
                isRunning = false -- No fruits, so stop
            end

            -- Loop while running AND there are still fruits AND at least one level is not maxed
            while isRunning and #fruits > 0 and (TranquilLevel < 5 or CorruptLevel < 5) do
                local fruitsSubmittedInThisPass = 0 -- Track if any fruits were submitted in this iteration

                -- Re-get fruits at the start of each major pass to ensure list is fresh
                getFruits()
    
                if #fruits == 0 then
                    print("No more fruits in inventory after re-scan. Stopping Kitsune loop.")
                    break -- No fruits left, break out of while loop
                end

                -- Iterate backwards for safe removal
                for i = #fruits, 1, -1 do
                    if not isRunning then break end -- Stop if toggle turned off or max levels reached externally

                    local fruit = fruits[i]
                    -- Double-check if fruit still exists and is valid
                    if not fruit or not fruit.Parent then
                        print("Kitsune: Fruit no longer exists or has no parent: Removing from list (index " .. i .. ")")
                        table.remove(fruits, i)
                        continue
                    end

                    local fruitName = fruit.Name
                    if shouldSkipItem(fruit.Name) then -- Uses the global shouldSkipItem
                        createColoredNotification("⏭ Skipping Kitsune: "..fruit.Name, "Rarity: Common")
                        -- table.remove(fruits, i) -- Optional: remove skipped items from the list
                        continue
                    end

                    local isTranquil = fruitName:find("Tranquil")
                    local isCorrupt = fruitName:find("Corrupt")

                    print(string.format("Kitsune: Checking fruit: %s (Tranquil: %s, Corrupt: %s). Current Levels: 🌿%d/5 ☠%d/5",
                                        fruitName, tostring(isTranquil), tostring(isCorrupt), TranquilLevel, CorruptLevel))
    
                    local shouldSubmit = false

                    -- REVISED LOGIC FOR KITSUNE
                    if isTranquil and TranquilLevel < 5 then
                        shouldSubmit = true
                    end
                    if isCorrupt and CorruptLevel < 5 then
                        shouldSubmit = true
                    end

                    print(string.format("Kitsune: Decision for %s: shouldSubmit = %s", fruitName, tostring(shouldSubmit)))

                    if shouldSubmit then
                        -- Check for 'd' attribute (favorited/do not submit)
                        if not fruit:GetAttribute("d") then
                            submitFruit(fruit) -- Uses the Kitsune-specific submitFruit
                            fruitsSubmittedInThisPass = fruitsSubmittedInThisPass + 1
                            table.remove(fruits, i) -- Remove the fruit from our list after attempting submission
                            task.wait(1.5) -- Short delay after submission

                            -- Re-read levels *immediately* after a successful submission
                            TranquilLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
                            CorruptLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)

                            -- Force validate levels
                            if not (type(TranquilLevel) == "number" and TranquilLevel >= 0 and TranquilLevel <= 5) then
                                TranquilLevel = 0
                                print("Kitsune WARNING: TranquilLevel became invalid, resetting to 0.")
                            end
                            if not (type(CorruptLevel) == "number" and CorruptLevel >= 0 and CorruptLevel <= 5) then
                                CorruptLevel = 0
                                print("Kitsune WARNING: CorruptLevel became invalid, resetting to 0.")
                            end

                            createColoredNotification(string.format("Updated Kitsune Levels: 🌿%d/5 ☠%d/5", TranquilLevel, CorruptLevel), "Rarity: Common")
                            print(string.format("Kitsune: Levels after submitting %s: Tranquil=%d, Corrupt=%d", fruitName, TranquilLevel, CorruptLevel))

                            -- If both levels are maxed out, break
                            if TranquilLevel == 5 and CorruptLevel == 5 then
                                createColoredNotification("Kitsune Zen levels are maxed out! Stopping submission.", "Rarity: Common")
                                isRunning = false
                                break
                            end
                        else
                            print("Kitsune: Skipping " .. fruitName .. " because it has a 'd' attribute.")
                        end
                    else
                        print("Kitsune: Fruit " .. fruitName .. " not submitted because conditions not met.")
                    end
                end -- End of Kitsune for loop

                if isRunning and fruitsSubmittedInThisPass == 0 and (#fruits > 0) then
                    print("Kitsune: No suitable fruits found to submit in this pass. Stopping automation.")
                    isRunning = false
                end

                if isRunning then task.wait(1) end -- Small wait between passes

            end -- End of Kitsune while loop

            -- Return to original position
            if playerPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                print("Kitsune: Returned to original position.")
            end

            -- Restore original tool
            if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                task.wait(0.5)
                savedTool.Parent = LocalPlayer.Character
                savedTool = nil
                print("Kitsune: Restored original tool.")
            end

            if not isRunning then
                createColoredNotification("✅ Kitsune fruit submission finished or stopped.", "Rarity: Common")
            else
                createColoredNotification("✅ Kitsune fruit submission completed!", "Rarity: Common")
            end
            isRunning = false -- Ensure flag is false on completion/stop
            print("Kitsune automation finished.")

        else
            -- Toggle OFF logic
            if isRunning then -- Only if it was running
                 isRunning = false -- Signal to stop
                 createColoredNotification("🔴 Stopped Kitsune fruit submission.", "Rarity: Common")
                 -- Restore tool if we were interrupted mid-process
                 if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                     savedTool.Parent = LocalPlayer.Character
                     savedTool = nil
                     print("Kitsune: Restored tool after manual stop.")
                 end
                 print("Kitsune: Toggle OFF: Automation stopped.")
            end
        end
    end

    -- Tranquil Toggle
    automationToggles.tranquil = function(state)
        if state then
            print("Toggle ON: Starting Tranquil NPC automation.")
            -- Prevent simultaneous execution if another automation is running
            if isRunning then
                createColoredNotification("🚫 Another automation is already running. Please turn it off first.", "Rarity: Common")
                return
            end

            -- Store currently equipped tool (if not a fruit)
            if LocalPlayer.Character then
                for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                    if item:IsA("Tool") and not (item.Name:find("Tranquil") or item.Name:find("Corrupt")) then
                        savedTool = item
                        item.Parent = LocalPlayer.Backpack
                        print("Saved equipped tool: " .. item.Name)
                        break
                    end
                end
            end

            isRunning = true -- Set flag to true as this automation starts
            createColoredNotification("✅ Starting Tranquil fruit submission...", "Rarity: Common")

            -- Store original position
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                playerPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
                print("Player position saved.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found. Cannot save position!", "Rarity: Common")
                isRunning = false
                return
            end

            -- Teleport to Tranquil NPC
            local tranquilNpcPosition = CFrame.new(-73.59021, 4.3999157, -12.1218204)
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = tranquilNpcPosition
                print("Teleporting to Tranquil NPC.")
                task.wait(1) -- Wait for teleport
                print("Teleport wait complete.")
            else
                createColoredNotification("❌ Character or HumanoidRootPart not found for teleport! Stopping.", "Rarity: Common")
                isRunning = false
                return
            end

            -- Main loop for submitting Tranquil fruits
            local submittedFruitCount = 0

            -- Loop indefinitely until no more tranquil fruits or toggle off
            while isRunning do
                local currentTranquilFruits = {}
                -- Re-scan for Tranquil fruits specifically in backpack
                -- Ensure it's only Tranquil, not dual
                for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end
                -- Check equipped tool for Tranquil fruit (and make sure it's not dual)
                if LocalPlayer.Character then
                    for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                        if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                            table.insert(currentTranquilFruits, item)
                        end
                    end
                end
                print("Tranquil NPC: Found " .. #currentTranquilFruits .. " potential Tranquil fruits.")

                -- Filter out any fruits that match the skip patterns or are favorited
                local submitableTranquilFruits = {}
                for _, fruit in ipairs(currentTranquilFruits) do
                    if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") then -- Uses the global shouldSkipItem
                        table.insert(submitableTranquilFruits, fruit)
                    else
                        createColoredNotification("⏭ Skipping Tranquil: "..fruit.Name, "Rarity: Common")
                        print("Tranquil NPC: Skipping " .. fruit.Name .. " (either skip pattern or 'd' attribute).")
                    end
                end
                print("Tranquil NPC: Found " .. #submitableTranquilFruits .. " submitable Tranquil fruits.")


                if #submitableTranquilFruits == 0 then
                    createColoredNotification("No more suitable Tranquil fruits found to submit.", "Rarity: Common")
                    print("Tranquil NPC: No suitable Tranquil fruits left. Stopping submission loop.")
                    break -- Exit the while loop
                end
    
                -- Equip and submit the first available tranquil fruit
                local fruitToSubmit = submitableTranquilFruits[1]
                print("Tranquil NPC: Attempting to submit fruit: " .. fruitToSubmit.Name)

                -- Equip the fruit
                fruitToSubmit.Parent = LocalPlayer.Character
                task.wait(0.2) -- Give time to equip
                print("Tranquil NPC: Fruit equipped: " .. fruitToSubmit.Name)

                -- Fire the RemoteEvent to submit all plants (which should consume the equipped one)
                local args = {"SubmitAllPlants"}
                game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("ZenQuestRemoteEvent"):FireServer(unpack(args))
                print("Tranquil NPC: Fired RemoteEvent: ZenQuestRemoteEvent with args 'SubmitAllPlants'")

                submittedFruitCount = submittedFruitCount + 1
                createColoredNotification(string.format("Submitted Tranquil fruit #%d", submittedFruitCount), "Rarity: Common")

                task.wait(1.0) -- Small delay after submission to allow server to process and inventory to update
            end -- End of Tranquil NPC while loop

            -- Automation finished, return to original position
            if playerPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = playerPosition
                print("Tranquil NPC: Returned to original position.")
            end

            -- Restore original tool if it still exists
            if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                task.wait(0.5)
                savedTool.Parent = LocalPlayer.Character
                savedTool = nil
                print("Tranquil NPC: Restored original tool.")
            end

            createColoredNotification("✅ Tranquil fruit submission completed!", "Rarity: Common")
            isRunning = false -- Ensure flag is false on completion/stop
            print("Tranquil NPC automation finished.")

        else
            -- Toggle OFF logic
            if isRunning then -- Only if it was running due to this toggle
                isRunning = false -- Signal to stop
                createColoredNotification("🔴 Stopped Tranquil fruit submission.", "Rarity: Common")
                -- Restore tool if we were interrupted mid-process
                if savedTool and savedTool.Parent == LocalPlayer.Backpack then
                    savedTool.Parent = LocalPlayer.Character
                    savedTool = nil
                    print("Tranquil NPC: Restored tool after manual stop.")
                end
                print("Tranquil NPC: Toggle OFF: Automation stopped.")
            end
        end
    end

    -- Create the UI toggles (for visual representation)
    tab2:CreateToggle("Auto Give Fruits to Kitsune", function(state)
        automationToggles.kitsune(state)
    end)

    tab2:CreateToggle("Auto Give Fruits to Tranquil NPC", function(state)
        automationToggles.tranquil(state)
    end)
end

createAutomationToggles()

local selectedMutation = nil
local autoPickupActive = false

-- List of attributes to ignore in the dropdown
local IGNORED_ATTRIBUTES = {
    "DoneGrowTime",
    "GrowRateMulti",
    "MaxAge",
    "FruitSpawnIndex",
    "FruitVersion",
    "WeightMulti",
    "SetVariant",
    "IsOutlined",
    "Inspected",
    "SkipRotation",
    "OfflineGrowthTarget",
    "WaitForPlantGenerated"
}

-- Function to scan farm for all available mutations (excluding ignored ones)
local function scanForMutations()
    local mutationList = {}
    
    if not playerFarm then
        playerFarm = findPlayerFarm()
        if not playerFarm then return mutationList end
    end

    local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
    if plantsPhysical then
        for _, plant in pairs(plantsPhysical:GetChildren()) do
            -- Check for Fruits folder
            local fruitsFolder = plant:FindFirstChild("Fruits")
            if fruitsFolder then
                for _, fruit in pairs(fruitsFolder:GetChildren()) do
                    -- Get all attributes (mutations)
                    for attrName, _ in pairs(fruit:GetAttributes()) do
                        -- Only add if not in ignored list
                        if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                            table.insert(mutationList, attrName)
                        end
                    end
                end
            else
                -- Check the plant itself if no Fruits folder
                for attrName, _ in pairs(plant:GetAttributes()) do
                    if not table.find(IGNORED_ATTRIBUTES, attrName) and not table.find(mutationList, attrName) then
                        table.insert(mutationList, attrName)
                    end
                end
            end
        end
    end
    
    return mutationList
end

-- Create the mutation dropdown with filtered mutations
local mutationDropdown = tab2:CreateDDO("Select Mutation", {}, function(selected)
    selectedMutation = selected
end)

-- Update mutation list initially and when farm changes (with ignored attributes filtered out)
task.spawn(function()
    while true do
        local mutations = scanForMutations() -- This now returns only non-ignored attributes
        mutationDropdown:SetOptions(mutations)
        wait(30) -- Rescan every 30 seconds
    end
end)

-- Auto pickup function (unchanged)
local function collectFruitsWithMutation()
    while autoPickupActive and selectedMutation do
        if not playerFarm then
            playerFarm = findPlayerFarm()
            if not playerFarm then break end
        end

        local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
        if plantsPhysical then
            for _, plant in pairs(plantsPhysical:GetChildren()) do
                -- Recursive function to scan all fruit parts
                local function scanFruitModel(model)
                    if model:GetAttribute(selectedMutation) then
                        -- Find the proximity prompt at any level
                        local prompt = model:FindFirstChildWhichIsA("ProximityPrompt")
                        if not prompt then
                            -- Deep search for prompts in all descendants
                            for _, descendant in pairs(model:GetDescendants()) do
                                if descendant:IsA("ProximityPrompt") then
                                    prompt = descendant
                                    break
                                end
                            end
                        end
                        
                        -- If prompt found, collect the fruit
                        if prompt then
                            -- Teleport to fruit
                            local char = LocalPlayer.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                local hrp = char.HumanoidRootPart
                                local originalPos = hrp.CFrame
                                
                                -- Teleport close to fruit
                                hrp.CFrame = model:GetPivot() * CFrame.new(0, 0, -2)
                                
                                -- Fire prompt
                                task.wait(0.2)
                                fireproximityprompt(prompt)
                                
                                -- Return to original position
                                task.wait(0.1)
                                hrp.CFrame = originalPos
                            end
                        end
                    end
                end

                -- Check both Fruits folder and direct children
                local fruitsFolder = plant:FindFirstChild("Fruits")
                if fruitsFolder then
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        -- Scan the fruit and all its nested children
                        scanFruitModel(fruit)
                        for _, subPart in pairs(fruit:GetDescendants()) do
                            if subPart:IsA("Model") or subPart:IsA("BasePart") then
                                scanFruitModel(subPart)
                            end
                        end
                    end
                else
                    -- Check the plant itself if no Fruits folder
                    scanFruitModel(plant)
                end
            end
        end
        
        task.wait(0.5) -- Delay between scans
    end
end

-- Create the toggle (unchanged)
tab2:CreateToggle("Auto Pickup Fruits with mutation", function(state)
    autoPickupActive = state
    if state then
        if not selectedMutation then
            sendNotification("Pickup Error", "Select a mutation first!", 5)
            return
        end
        task.spawn(collectFruitsWithMutation)
        sendNotification("Auto Pickup", "Started collecting "..selectedMutation, 5)
    else
        sendNotification("Auto Pickup", "Stopped collecting", 3)
    end
end)

tab3:CreateButton("Sprinkler Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Phynomie/tg/refs/heads/main/script.lua"))()
end)

local tab4 = Main:CreateTab("Fruit Automation")

local targetFruits = {"Serenity", "Zenflare", "Soft Sunshine", "Maple Apple"}
local maxBackpackItems = 441
local fruitAutomationActive = false
local loopCount = 0
local blacklistedFruits = {} -- New table to track problematic fruits

local function sellAllFruits()
    if not fruitAutomationActive then return false end -- Early exit if toggled off
    
    local steven = workspace.NPCS:FindFirstChild("Steven")
    if not steven then
        warn("Steven NPC not found!")
        return false
    end
    
    local npcHRP = steven:FindFirstChild("HumanoidRootPart")
    if not npcHRP then
        warn("Steven doesn't have HumanoidRootPart!")
        return false
    end
    
    local playerChar = LocalPlayer.Character
    if not playerChar then
        warn("Player character not found!")
        return false
    end
    
    local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHRP then
        warn("Player doesn't have HumanoidRootPart!")
        return false
    end
    
    local originalCFrame = playerHRP.CFrame
    
    -- Teleport to Steven
    playerHRP.CFrame = npcHRP.CFrame * CFrame.new(0, 0, -3) 
    task.wait(0.5)
    
    -- Sell all fruits
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Sell_Inventory"):FireServer()
    createColoredNotification("Sold all remaining fruits", "Rarity: Common")
    task.wait(0.5)
    
    -- Return to original position
    playerHRP.CFrame = originalCFrame
    return true
end

-- Modified Kitsune submission function with safety checks
local function safeSubmitToKitsune(fruit)
    if not fruitAutomationActive then return false end -- Early exit if toggled off
    
    -- Check if fruit is blacklisted
    if blacklistedFruits[fruit] then
        print("Skipping blacklisted fruit: "..fruit.Name)
        return false
    end
    
    -- Check if player is holding more than 1 tool (should never happen)
    if LocalPlayer.Character then
        local equippedTools = 0
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                equippedTools = equippedTools + 1
            end
        end
        
        if equippedTools > 1 then
            -- Unequip all tools and try again
            for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                if item:IsA("Tool") then
                    item.Parent = LocalPlayer.Backpack
                end
            end
            task.wait(0.5)
            return false
        end
    end
    
    -- Equip the fruit
    fruit.Parent = LocalPlayer.Character
    task.wait(0.5) -- Give more time to equip
    
    -- Verify the fruit was equipped
    if fruit.Parent ~= LocalPlayer.Character then
        print("Failed to equip fruit: "..fruit.Name)
        blacklistedFruits[fruit] = true -- Add to blacklist
        return false
    end
    
    -- Submit to Kitsune
    local args = {"SubmitToFox"}
    game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))
    
    -- Wait and verify if fruit was consumed
    local startTime = os.clock()
    while os.clock() - startTime < 2 do -- Wait up to 2 seconds
        if fruit.Parent ~= LocalPlayer.Character then
            break -- Fruit was consumed
        end
        task.wait(0.1)
    end
    
    -- If fruit still exists after submission, blacklist it
    if fruit.Parent == LocalPlayer.Character then
        print("Fruit not consumed after submission: "..fruit.Name)
        blacklistedFruits[fruit] = true
        fruit.Parent = LocalPlayer.Backpack -- Put it back
        return false
    end
    
    return true
end

-- Modified collectTargetFruits function with better phase interruption
local function collectTargetFruits()
    while fruitAutomationActive do
        loopCount = loopCount + 1
        createColoredNotification(string.format("Starting AFK loop #%d", loopCount), "Rarity: Common")
        
        -- Store original position once at start of collection phase
        local originalPos
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            originalPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        end
        
        -- PHASE 1: CONTINUOUS FRUIT COLLECTION
        while fruitAutomationActive and #LocalPlayer.Backpack:GetChildren() < maxBackpackItems do
            if not playerFarm then
                playerFarm = findPlayerFarm()
                if not playerFarm then 
                    task.wait(5)
                    continue 
                end
            end

            local plantsPhysical = playerFarm:FindFirstChild("Important"):FindFirstChild("Plants_Physical")
            if plantsPhysical then
                for _, plant in pairs(plantsPhysical:GetChildren()) do
                    local fruitsFolder = plant:FindFirstChild("Fruits") or plant
                    
                    -- Scan all fruits in the plant
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        if not fruitAutomationActive then break end -- Check if toggled off
                        if #LocalPlayer.Backpack:GetChildren() >= maxBackpackItems then break end
                        
                        -- Check if target fruit and ready to harvest
                        local isTargetFruit = false
                        for _, targetName in pairs(targetFruits) do
                            if fruit.Name:find(targetName) and fruit:GetAttribute("DoneGrowTime") then
                                isTargetFruit = true
                                break
                            end
                        end
                        
                        if isTargetFruit then
                            -- Find prompt (optimized search)
                            local prompt = fruit:FindFirstChildWhichIsA("ProximityPrompt")
                            if not prompt then
                                for _, part in pairs(fruit:GetDescendants()) do
                                    if part:IsA("BasePart") and part:FindFirstChildWhichIsA("ProximityPrompt") then
                                        prompt = part:FindFirstChildWhichIsA("ProximityPrompt")
                                        break
                                    end
                                end
                            end
                            
                            -- Collect if prompt found
                            if prompt and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                local hrp = LocalPlayer.Character.HumanoidRootPart
                                hrp.CFrame = fruit:GetPivot() * CFrame.new(0, 0, -2.5)
                                task.wait(0.15)
                                fireproximityprompt(prompt)
                                createColoredNotification("Collected "..fruit.Name.." ("..#LocalPlayer.Backpack:GetChildren().."/"..maxBackpackItems..")", "Rarity: Common")
                                task.wait(0.5)
                            end
                        end
                    end
                    if not fruitAutomationActive then break end -- Check if toggled off
                end
            end
            if not fruitAutomationActive then break end -- Check if toggled off
            task.wait(0.5)
        end

        if not fruitAutomationActive then break end -- Check if toggled off before next phase

        -- Return to original position after collection phase
        if originalPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = originalPos
            task.wait(0.5)
        end

        if not fruitAutomationActive then break end -- Check if toggled off before next phase

        -- PHASE 2: KITSUNE AUTOMATION
        createColoredNotification("Starting Kitsune submission...", "Rarity: Common")
        if automationToggles.kitsune and fruitAutomationActive then
            -- Modified Kitsune automation with safety checks
            local kitsuneSuccess = false
            while fruitAutomationActive and not kitsuneSuccess do
                -- Get current levels
                local TranquilLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.TranquilSide.BillBoardPart.BillboardGui.TranquilLevelAmount.Text)
                local CorruptLevel = tonumber(workspace.Interaction.UpdateItems["Corrupted Zen"].MiddleTree.Tree.CorruptSide.BillBoardPart.BillboardGui.CorruptionLevelAmount.Text)
                
                if TranquilLevel == 5 and CorruptLevel == 5 then
                    kitsuneSuccess = true
                    break
                end
                
                -- Find suitable fruits
                getFruits()
                local submittedAny = false
                
                for i = #fruits, 1, -1 do
                    if not fruitAutomationActive then break end
                    
                    local fruit = fruits[i]
                    if not fruit or not fruit.Parent then
                        table.remove(fruits, i)
                        continue
                    end
                    
                    local fruitName = fruit.Name
                    if shouldSkipItem(fruit.Name) or fruit:GetAttribute("d") or blacklistedFruits[fruit] then
                        continue
                    end

                    local isTranquil = fruitName:find("Tranquil")
                    local isCorrupt = fruitName:find("Corrupt")
                    
                    if (isTranquil and TranquilLevel < 5) or (isCorrupt and CorruptLevel < 5) then
                        if safeSubmitToKitsune(fruit) then
                            submittedAny = true
                            table.remove(fruits, i)
                            task.wait(1.5)
                            break -- Submit one at a time with checks
                        end
                    end
                end
                
                if not submittedAny then
                    kitsuneSuccess = true -- No more fruits to submit
                end
                
                task.wait(1)
            end
        end

        if not fruitAutomationActive then break end -- Check if toggled off before next phase

        -- PHASE 3: TRANQUIL AUTOMATION
        createColoredNotification("Starting Tranquil submission...", "Rarity: Common")
        if automationToggles.tranquil and fruitAutomationActive then
            -- Modified Tranquil automation with safety checks
            local tranquilSuccess = false
            while fruitAutomationActive and not tranquilSuccess do
                -- Find tranquil fruits
                local currentTranquilFruits = {}
                for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                        table.insert(currentTranquilFruits, item)
                    end
                end
                
                if LocalPlayer.Character then
                    for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                        if item:IsA("Tool") and item.Name:find("Tranquil") and not item.Name:find("Corrupt") then
                            table.insert(currentTranquilFruits, item)
                        end
                    end
                end
                
                -- Filter out skipped/blacklisted fruits
                local submitableTranquilFruits = {}
                for _, fruit in ipairs(currentTranquilFruits) do
                    if not shouldSkipItem(fruit.Name) and not fruit:GetAttribute("d") and not blacklistedFruits[fruit] then
                        table.insert(submitableTranquilFruits, fruit)
                    end
                end
                
                if #submitableTranquilFruits == 0 then
                    tranquilSuccess = true
                    break
                end
                
                -- Submit one fruit at a time with checks
                local fruitToSubmit = submitableTranquilFruits[1]
                fruitToSubmit.Parent = LocalPlayer.Character
                task.wait(0.5)
                
                -- Fire the RemoteEvent
                local args = {"SubmitAllPlants"}
                game:GetService("ReplicatedStorage").GameEvents.ZenQuestRemoteEvent:FireServer(unpack(args))
                
                -- Verify submission
                local startTime = os.clock()
                while os.clock() - startTime < 2 do
                    if fruitToSubmit.Parent ~= LocalPlayer.Character then
                        break -- Fruit was consumed
                    end
                    task.wait(0.1)
                end
                
                -- If fruit still exists, blacklist it
                if fruitToSubmit.Parent == LocalPlayer.Character then
                    blacklistedFruits[fruitToSubmit] = true
                    fruitToSubmit.Parent = LocalPlayer.Backpack
                end
                
                task.wait(1.5)
            end
        end

        if not fruitAutomationActive then break end -- Check if toggled off before next phase

        -- PHASE 4: SELL REMAINING FRUITS
        createColoredNotification("Selling remaining fruits...", "Rarity: Common")
        sellAllFruits()
        
        if not fruitAutomationActive then break end -- Final check before loop continues
        
        createColoredNotification(string.format("Completed AFK loop #%d", loopCount), "Rarity: Common")
        task.wait(3)
    end
    
    -- Cleanup when loop ends
    blacklistedFruits = {} -- Reset blacklist
    createColoredNotification("AFK farming loop stopped", "Rarity: Common")
end

tab4:CreateToggle("AFK Fruit Farm Loop", function(state)
    fruitAutomationActive = state
    if state then
        loopCount = 0
        blacklistedFruits = {} -- Reset blacklist on start
        createColoredNotification("Started optimized AFK farming loop:\n1. Collect Fruits → 2. Kitsune → 3. Tranquil → 4. Sell → Repeat", "Rarity: Common")
        task.spawn(collectTargetFruits)
    else
        createColoredNotification("Stopping AFK farming loop...", "Rarity: Common")
    end
end)

tab:Show()

library.OnDestroy = function()
    print("Destroying all created instances...")
    
    -- Stop all loops
    for _, loop in pairs(cleanup.loops) do
        if type(loop) == "thread" then
            coroutine.close(loop)
        end
    end
    
    -- Disconnect all connections
    for _, connection in ipairs(cleanup.connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    
    -- Reset prompts
    managePrompts(false)
    
    -- Destroy GUI instances
    if cleanup.countdownGui then
        cleanup.countdownGui:Destroy()
    end
    
    -- Reset variables
    enabled = nil
    autoBuyActive = false
    savedPrompts = {}
    playerFarm = nil
    
    -- Clear tables
    cleanup.connections = {}
    cleanup.loops = {}

    if petCooldownConnection then
        petCooldownConnection:Disconnect()
        petCooldownConnection = nil
    end
    
    for _, data in pairs(petCooldownDisplays) do
        if data.display and data.display.Parent then
            data.display.Parent:Destroy()
        end
    end
    petCooldownDisplays = {}

    fruitAutomationActive = false

    getgenv().script_loaded = false
    
    print("Cleanup complete!")
end
